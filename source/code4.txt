tionFile");
const ApRseModel = require("../models/ApRse");
const AdrBlkModel = require("../models/AdrBlk");
const SysMetaDataModel = require("../models/Sys_Meta_Data");
const sequelize = require("../config/database");
const { generateApplicationNo } = require("../utils/applicationUtils");
const { getUserJsonWithToken } = require("../utils/loginUtils");
const { v4: uuidv4 } = require("uuid");
const multer = require("multer");
const path = require("path");
const fs = require("fs");
const zip = require("node-zip");
const { QueryTypes } = require("sequelize");
const { camelize } = require("../utils/on9Dotnet");
const sendEmail = require("../utils/sendEmail");

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "wwwroot/uploads"); // Directory where files are saved
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = uuidv4(); // Generate a unique identifier
    const fileExtension = path.extname(file.originalname); // Extract the file extension
    cb(null, `${uniqueSuffix}${fileExtension}`); // Append the extension to the filename
  },
});

const upload = multer({ storage });

const capitalizeKeys = (obj) => {
  // Create a new object to store the updated key-value pairs
  const capitalizedObj = {};

  // Loop through each key in the original object
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // Capitalize the first letter of the key
      let capitalizedKey = "";
      if (key.startsWith("bd")) {
        capitalizedKey =
          key.charAt(0).toUpperCase() +
          key.charAt(1).toUpperCase() +
          key.slice(2);
      } else {
        capitalizedKey = key.charAt(0).toUpperCase() + key.slice(1);
      }

      // If the value is an object, recursively capitalize its keys
      if (typeof obj[key] === "object" && !Array.isArray(obj[key])) {
        capitalizedObj[capitalizedKey] = capitalizeKeys(obj[key]);
      } else {
        // Otherwise, just assign the value to the new key in the new object
        capitalizedObj[capitalizedKey] = obj[key];
      }
    }
  }

  return capitalizedObj;
};

const lowercaseKeys = (obj) => {
  const lowercasedObj = {};

  // Loop through each key in the original object
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // Convert the key to lowercase
      let lowercasedKey = "";
      if (key.startsWith("BD")) {
        lowercasedKey =
          key.charAt(0).toLowerCase() +
          key.charAt(1).toLowerCase() +
          key.slice(2);
      } else {
        lowercasedKey = key.charAt(0).toLowerCase() + key.slice(1);
      }
      // Check if the value is a Date, null, or other types
      if (obj[key] instanceof Date) {
        lowercasedObj[lowercasedKey] = obj[key]; // Keep the date unchanged
      } else if (
        obj[key] !== null &&
        typeof obj[key] === "object" &&
        !Array.isArray(obj[key])
      ) {
        lowercasedObj[lowercasedKey] = lowercaseKeys(obj[key]); // Recursively process nested objects
      } else {
        // Otherwise, preserve the original value
        lowercasedObj[lowercasedKey] = obj[key];
      }
    }
  }

  return lowercasedObj;
};

router.post("/newschoolsubmission", async (req, res, next) => {
  try {
    let applicationReq = req.body;
    applicationReq = capitalizeKeys(applicationReq);
    if (applicationReq.ApplicationNo === "") {
      // new application create new application no
      const newApplicationNo = await generateApplicationNo(
        applicationReq.Form.ApplicationType
      );
      applicationReq.Form.ApplicationNo = newApplicationNo;
    } else {
      applicationReq.Form.ApplicationNo = applicationReq.ApplicationNo;
    }
    if (applicationReq.Form.ApList) {
      applicationReq.Form.ApList = JSON.stringify(applicationReq.Form.ApList);
    }
    if (applicationReq.Form.SelfCertification) {
      applicationReq.Form.SelfCertification = JSON.stringify(
        applicationReq.Form.SelfCertification
      );
    }
    if (
      applicationReq.Form.FormName === "inspect-req" ||
      applicationReq.Form.FormName === "update-info" ||
      applicationReq.Form.FormName === "appoint-ap" ||
      applicationReq.Form.FormName === "withdraw-app"
    ) {
      applicationReq.Form.Date = new Date();
      applicationReq.Form.SubmittedDate = new Date();
    }
    if (applicationReq.Form.FormName === "update-info") {
      if (!applicationReq.Form.ApplicantNameEN) {
        applicationReq.Form.ApplicantNameEN = applicationReq.Form.ApplicantName;
      }
    }
    const newSubmssionId = uuidv4();
    applicationReq.Form.SubmissionId = newSubmssionId;
    if (
      applicationReq.Form.FormName === "A2" ||
      applicationReq.Form.FormName === "E2" ||
      applicationReq.Form.FormName === "CCCAI-C2" ||
      applicationReq.Form.FormName === "EDB-JOKC02" ||
      applicationReq.Form.FormName === "CCCAI-MH3"
    ) {
      if (!applicationReq.Form.ApplicantNameEN) {
        applicationReq.Form.ApplicantNameEN = applicationReq.Form.ApplicantName;
      }
      const applicationInfo = await SchoolAppInfoModel.create(
        applicationReq.Form
      );
      if (!applicationInfo) {
        return res.status(400).json({ error: "Create application fail" });
      }
    }
    const getUser = await getUserJsonWithToken({
      applicationNo: applicationReq.Form.ApplicationNo,
      userId: applicationReq.Form.UpdatedBy,
    });
    applicationReq.Form.UpdatedBy = getUser.role;
    await SchoolAppInfoModel.update(applicationReq.Form, {
      where: { ApplicationNo: applicationReq.Form.ApplicationNo },
    });
    const applicationResponse = await SchoolAppSubmissionModel.create(
      applicationReq.Form
    );
    if (!applicationResponse) {
      return res.status(400).json({ error: "Create application fail" });
    }

    // If it is withdraw form, update the status of the application
    if (applicationReq.Form.FormName === "withdraw-app") {
      await SchoolAppInfoModel.update(
        { Status: "Abandoned" },
        { where: { ApplicationNo: applicationReq.Form.ApplicationNo } }
      );
    }

    let successResponse = {};
    if (
      applicationReq.Form.FormName === "A2" ||
      applicationReq.Form.FormName === "E2" ||
      applicationReq.Form.FormName === "CCCAI-C2" ||
      applicationReq.Form.FormName === "EDB-JOKC02" ||
      applicationReq.Form.FormName === "CCCAI-MH3"
    ) {
      successResponse = {
        meta: {
          code: 200,
          message: "OK",
        },
        data: {
          applicationNo: applicationReq.Form.ApplicationNo,
          submissionId: newSubmssionId,
          msg: "Saved Successfully",
          userId: getUser.userId,
          role: getUser.role,
          token: getUser.token,
        },
      };
    } else {
      successResponse = {
        meta: {
          code: 200,
          message: "OK",
        },
        data: {
          applicationNo: applicationReq.Form.ApplicationNo,
          submissionId: newSubmssionId,
          msg: "Saved Successfully",
        },
      };
    }

    res.status(200).json(successResponse);
  } catch (err) {
    next(err);
  }
});

router.post("/updateschoolsubmission", async (req, res, next) => {
  try {
    let applicationReq = req.body;
    applicationReq = capitalizeKeys(applicationReq);
    if (applicationReq.Form.Status === "Submitted") {
      applicationReq.Form.SubmittedDate = new Date();
      const getUser = await getUserJsonWithToken({
        applicationNo: applicationReq.ApplicationNo,
        userId: applicationReq.Form.UpdatedBy,
      });
      applicationReq.Form.UpdatedBy = getUser.role;
    }
    if (applicationReq.Form.ApList) {
      applicationReq.Form.ApList = JSON.stringify(applicationReq.Form.ApList);
    }
    if (applicationReq.Form.SelfCertification) {
      applicationReq.Form.SelfCertification = JSON.stringify(
        applicationReq.Form.SelfCertification
      );
    }
    const appInfo = await SchoolAppInfoModel.update(applicationReq.Form, {
      where: { ApplicationNo: applicationReq.ApplicationNo },
      returning: true,
      plain: true,
    });

    const applicationResponse = await SchoolAppSubmissionModel.update(
      applicationReq.Form,
      {
        where: {
          ApplicationNo: applicationReq.ApplicationNo,
          SubmissionId: applicationReq.Form.SubmissionId,
        },
      }
    );

    if (!applicationResponse) {
      return res.status(400).json({ error: "Application update failed" });
    }

    // const deleteFormAttachment = await ApplicationFileModel.destroy({
    //   where: {
    //     SubmissionId: applicationReq.Form.SubmissionId,
    //     DocumentType: "form",
    //   },
    // });

    const updatedApplication = await SchoolAppSubmissionModel.findOne({
      where: { SubmissionId: applicationReq.Form.SubmissionId },
    });
    console.log("App info", appInfo);
    if (!updatedApplication) {
      return res
        .status(400)
        .json({ error: "Application not found, update failed" });
    }
    if (applicationReq.Form.Status === "Submitted") {
      // send email
      await sendEmail(
        appInfo?.[1]?.dataValues?.ApplicantEmail,
        `Application received: ${appInfo?.[1]?.dataValues?.ApplicationNo}`,
        `
  Dear Sir/Madam,
  
  Your application  number is ${appInfo?.[1]?.dataValues?.ApplicationNo}.
  
  For enquiry, please contact us at telephone no. 2626 1616 (Handled by “1823”) or via email non-reply_LSCP@bd.gov.hk.
  
  Please do not reply to this email as it comes from an automated mailbox.
  
  Buildings Department
              `
      );
    }
    const successResponse = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        applicationNo: applicationReq.ApplicationNo,
        submissionId: updatedApplication.dataValues.SubmissionId,
        msg: "Saved Successfully",
        userId: null,
        role: null,
        token: null,
      },
    };

    res.status(200).json(successResponse);
  } catch (err) {
    next(err);
  }
});

router.get("/getapplicationcasealldata", async (req, res, next) => {
  try {
    const applicationNo = req.query.applicationNo.trim();
    const applicationResponse = await SchoolAppSubmissionModel.findAll({
      where: { ApplicationNo: applicationNo },
      raw: true, // This ensures Sequelize does not format the results and keeps the original data types.
    });
    const applicationInfo = await SchoolAppInfoModel.findOne({
      where: { ApplicationNo: applicationNo },
    });
    const lowerCasedApplication = applicationResponse.map((application) => {
      const lowerCasedDataValues = {};

      // Iterate through each key in dataValues and convert it to lowercase
      Object.keys(application).forEach((key) => {
        lowerCasedDataValues[key.charAt(0).toLowerCase() + key.slice(1)] =
          application[key];
      });
      return lowerCasedDataValues;
    });

    const backendUpdates = await BackendUpdateModel.findAll({
      where: { ApplicationNo: applicationNo },
    });

    let appInfoData = lowercaseKeys(applicationInfo?.dataValues);
    let appSubmissionData = lowerCasedApplication;

    try {
      if (appInfoData.apList)
        appInfoData.apList = JSON.parse(appInfoData.apList);
      if (appInfoData.selfCertification)
        appInfoData.selfCertification = JSON.parse(
          appInfoData.selfCertification
        );
      if (appSubmissionData.apList)
        appSubmissionData.apList = JSON.parse(appSubmissionData.apList);
      if (appSubmissionData.selfCertification)
        appSubmissionData.selfCertification = JSON.parse(
          appSubmissionData.selfCertification
        );
    } catch (e) {}

    const successResponse = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        applicationNo: applicationNo,
        appSubmissions: appSubmissionData,
        appInfo: appInfoData,
        backendUpdates: backendUpdates.map((update) =>
          lowercaseKeys(update.dataValues)
        ),
      },
    };
    return res.status(200).json(successResponse);
  } catch (err) {
    next(err);
  }
});

router.get("/getapplicationsubmissionandinfo", async (req, res, next) => {
  try {
    const submisstionId = req.query.submissionId.trim();

    const applicationResponse = await SchoolAppSubmissionModel.findOne({
      where: { SubmissionId: submisstionId },
    });

    if (!applicationResponse) {
      return res.status(400).json({ error: "Application not found!" });
    }

    const applicationInfo = await SchoolAppInfoModel.findOne({
      where: { ApplicationNo: applicationResponse.dataValues.ApplicationNo },
    });

    let appInfoData = lowercaseKeys(applicationInfo?.dataValues);
    let appSubmissionData = lowercaseKeys(applicationResponse?.dataValues);

    try {
      if (appInfoData.apList)
        appInfoData.apList = JSON.parse(appInfoData.apList);
      if (appInfoData.selfCertification)
        appInfoData.selfCertification = JSON.parse(
          appInfoData.selfCertification
        );
      if (appSubmissionData.apList)
        appSubmissionData.apList = JSON.parse(appSubmissionData.apList);
      if (appSubmissionData.selfCertification)
        appSubmissionData.selfCertification = JSON.parse(
          appSubmissionData.selfCertification
        );
    } catch (e) {}

    const successResponse = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        applicationNo: applicationResponse.dataValues.ApplicationNo,
        appInfo: appInfoData,
        appSubmission: appSubmissionData,
      },
    };
    return res.status(200).json(successResponse);
  } catch (err) {
    next(err);
  }
});

router.get("/get-file-list/:submissionId", async (req, res, next) => {
  try {
    const { submissionId } = req.params;

    const applicationFiles = await ApplicationFileModel.findAll({
      where: { SubmissionId: submissionId },
      raw: true, // This ensures Sequelize does not format the results and keeps the original data types.
    });

    if (!applicationFiles) {
      return res.status(400).json({ error: "ApplicationFile not found!" });
    }
    const lowerCasedAttachments = applicationFiles.map((applicationFile) => {
      const lowerCasedDataValues = {};

      // Iterate through each key in dataValues and convert it to lowercase
      Object.keys(applicationFile).forEach((key) => {
        lowerCasedDataValues[key.charAt(0).toLowerCase() + key.slice(1)] =
          applicationFile[key];
        if (key === "FileSize") {
          lowerCasedDataValues["fileSize"] = parseInt(applicationFile[key]);
        }
      });
      return lowerCasedDataValues;
    });

    return res.status(200).json({
      meta: { code: 200, message: "OK" },
      data: lowerCasedAttachments,
    });
  } catch (err) {
    console.log(err);
    next(err);
  }
});

router.get("/get-file/:fileId", async (req, res, next) => {
  try {
    const { fileId } = req.params;
    const applicationFile = await ApplicationFileModel.findOne({
      where: { FileId: fileId },
    });
    if (fs.existsSync(applicationFile.FilePath)) {
      res.setHeader(
        "Content-Disposition",
        'inline; filename="' + path.basename(applicationFile.FilePath) + '"'
      );
      // res.setHeader("Content-Type", "application/pdf");
      // res.setHeader("Content-Length", fs.statSync(attachment.FilePath).size);

      // Stream the file content
      const fileStream = fs.createReadStream(applicationFile.FilePath);
      fileStream.pipe(res);
    } else {
      res.status(404).json({ error: "File not found" });
    }
  } catch (err) {
    console.log(err);
    next(err);
  }
});

router.get("/download-update/:backendUpdateId", async (req, res, next) => {
  try {
    const { backendUpdateId } = req.params;
    const backendUpdate = await BackendUpdateModel.findOne({
      where: { Id: backendUpdateId },
    });

    if (backendUpdate.dataValues.File) {
      let file = JSON.parse(backendUpdate.dataValues.File);
      if (!fs.existsSync(file.path)) {
        res.status(404).json({ error: "File not found" });
        res.status(404).json({ error: "File not found" });
      }

      res.setHeader(
        "Content-Disposition",
        `attachment; filename=${file.originalname}`
      );
      res.setHeader("Content-Type", backendUpdate.dataValues.FileMimeType);

      // Stream the file content
      const fileStream = fs.createReadStream(file.path);
      fileStream.pipe(res);
    } else {
      res.status(404).json({ error: "File not found" });
    }
  } catch (err) {
    console.log(err);
    next(err);
  }
});

router.get("/download-file/:submissionId", async (req, res, next) => {
  try {
    const { submissionId } = req.params;

    // Fetch all attachments for the given submissionId
    const attachments = await ApplicationFileModel.findAll({
      where: { SubmissionId: submissionId },
    });

    if (!attachments || attachments.length === 0) {
      return res.status(404).json({ error: "Attachments not found" });
    }

    const newZip = new zip(); // Initialize a new zip object

    // Loop through each attachment and add it to the zip file
    attachments.forEach((attachment) => {
      const filePath = attachment.FilePath;
      const fileName = attachment.FileName;

      // Ensure the file exists before adding it to the zip
      if (fs.existsSync(filePath)) {
        // Read the PDF file and add it to the zip
        const pdfContent = fs.readFileSync(filePath);
        newZip.file(`${fileName}.pdf`, pdfContent); // Explicitly add ".pdf" to file name
      } else {
        console.log(`File not found: ${filePath}`);
      }
    });

    // Generate the zip file
    const data = newZip.generate({ base64: false, compression: "DEFLATE" });

    // Set headers and send the zip file with the prefix "ApplicationCaseFiles"
    const zipFileName = `ApplicationCaseFiles_${submissionId}.zip`;
    res.setHeader("Content-Type", "application/zip");
    res.setHeader("Content-Disposition", `attachment; filename=${zipFileName}`);
    res.status(200).send(Buffer.from(data, "binary"));
  } catch (err) {
    console.log(err);
    next(err);
  }
});

router.post("/upload-file", upload.single("file"), async (req, res, next) => {
  try {
    const {
      formName,
      applicationNo,
      applicationType,
      submissionId,
      documentType,
      signDate,
      signType,
      createdBy,
    } = req.body;
    const file = req.file;
    let applicationResponse = {};
    if (formName === "submit-doc") {
      try {
        const submissionId = uuidv4();
        const application = {
          ApplicationNo: applicationNo,
          SubmissionId: submissionId,
          FormName: formName,
          ApplicationType: applicationType,
          Status: "Draft",
        };
        applicationResponse = await SchoolAppSubmissionModel.create(
          application
        );
      } catch (error) {
        console.log(error);
        return res
          .status(400)
          .json({ error: "Fail to create upload submission" });
      }
    } else {
      applicationResponse = await SchoolAppSubmissionModel.findOne({
        where: { SubmissionId: submissionId },
      });
    }
    if (!applicationResponse) {
      return res.status(400).json({ error: "Application not found!" });
    }

    // Handle 'form' attachment type
    if (documentType === "form") {
      const existingAttachment = await ApplicationFileModel.findOne({
        where: { SubmissionId: submissionId, DocumentType: "form" },
      });
      if (existingAttachment) {
        try {
          // Delete the old form file
          const oldFilePath = `wwwroot/uploads/${existingAttachment.FileName}`;
          await fs.promises.unlink(oldFilePath).catch(() => {});
          await ApplicationFileModel.destroy({
            where: { FileId: existingAttachment.FileId },
          });
        } catch (error) {
          console.error("Update failed:", error);
          return res.status(500).json({ error: "Failed to update attachment" });
        }
      }
    }

    const newApplicationFile = await ApplicationFileModel.create({
      ApplicationNo: applicationResponse.dataValues.ApplicationNo,
      SubmissionId: applicationResponse.dataValues.SubmissionId,
      DocumentType: documentType,
      FileId: file.filename.slice(0, -4),
      FileName: file.filename,
      FilePath: file.path,
      FileSize: file.size,
      SignDate: signDate,
      SignType: signType,
      CreatedBy: createdBy,
    });
    // const newAttachment = await AttachmentModel.create({
    //   ApplicationNo: applicationResponse.dataValues.ApplicationNo,
    //   SubmissionId: applicationResponse.dataValues.SubmissionId,
    //   DocumentType: documentType,
    //   FileId: file.filename.slice(0, -4),
    //   FileName: file.filename,
    //   FilePath: file.path,
    //   FileSize: file.size,
    // });

    const successResponse = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        applicationFile: lowercaseKeys(newApplicationFile.dataValues),
        returnMsg: null,
      },
    };

    res.status(200).json(successResponse);
  } catch (err) {
    console.log(err, "error");
    next(err);
  }
});

router.delete("/delete-file/:fileId", async (req, res, next) => {
  try {
    const { fileId } = req.params;
    const attachment = await ApplicationFileModel.destroy({
      where: { FileId: fileId },
    });
    if (!attachment) {
      return res.status(404).json({ error: "File not found" });
    } else {
      return res
        .status(200)
        .json({ meta: { code: 200, message: "OK" }, data: { success: true } });
    }
  } catch (err) {
    console.log(err);
    next(err);
  }
});

router.post("/getmasterdata", async (req, res, next) => {
  try {
    let applicationReq = req.body;
    applicationReq = capitalizeKeys(applicationReq);
    const { Type, Code } = applicationReq;
    if (Type == null || Code == null) {
      return res.status(400).json({ error: "Type and Code are required" });
    }
    const masterData = await ScsMasterTableModel.findAll({
      where: { Type, Code },
      raw: true, // This ensures Sequelize does not format the results and keeps the original data types.
    });
    let response = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: masterData.map((data) => lowercaseKeys(data)),
    };
    return res.status(200).json(response);
  } catch (err) {
    next(err);
  }
});

router.post("/find-aprse", async (req, res, next) => {
  try {
    const { chineseName, englishName, regType, certRegNo } = req.body;
    const regNo = regType + " " + certRegNo.trim();
    const apRse = await ApRseModel.findOne({
      where: {
        Name_tc: chineseName,
        Name: englishName,
        RegistrationType: regType,
        RegistrationNumber: regNo,
      },
    });
    if (!apRse) {
      return res.status(404).json({ error: "AP/RSE not found" });
    }
    const response = {
      meta: {
        code: 200,
        message: "OK",
      },

      data: lowercaseKeys(apRse.dataValues),
    };
    return res.status(200).json(response);
  } catch (err) {
    next(err);
  }
});

router.post("/find-Address", async (req, res, next) => {
  try {
    let applicationReq = req.body;
    applicationReq = capitalizeKeys(applicationReq);
    const {
      BuildingId = "",
      BuildingName = "",
      StreetName = "",
      DD = "",
      Lot = "",
    } = applicationReq;
    let addresses = [];
    if (BuildingId.trim() !== "") {
      try {
        const _id = parseInt(BuildingId, 10);

        const query = await sequelize.query(
          `
          SELECT
              TOP 10
              a.*, 
              district.ENGLISH_DESCRIPTION AS district_e, 
              district.CHINESE_DESCRIPTION AS district_c,
              (SELECT ENGLISH_DESCRIPTION AS region_e FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.SYS_REGION_ID) AS region_e,
              (SELECT CHINESE_DESCRIPTION AS region_c FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.SYS_REGION_ID) AS region_c,
              area.ENGLISH_DESCRIPTION AS area_e,
              area.CHINESE_DESCRIPTION AS area_c,
              (SELECT ENGLISH_DESCRIPTION AS bt_e FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.BLK_TYPE_ID) AS bt_e,
              (SELECT CHINESE_DESCRIPTION AS bt_c FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.BLK_TYPE_ID) AS bt_c
        
              FROM AdrBlk a
          LEFT JOIN Sys_Meta_Data district 
            ON a.SYS_DISTRICT_ID = district.SYS_META_DATA_ID
          LEFT JOIN Sys_Meta_Data region 
            ON a.SYS_REGION_ID = district.SYS_META_DATA_ID
          LEFT JOIN Sys_Meta_Data area 
            ON a.AREA_ID = area.SYS_META_DATA_ID

          WHERE a.ADR_BLK_ID = :id
          AND a.OBSOLETE = 'N'
          `,
          {
            replacements: { id: _id },
            type: QueryTypes.SELECT,
          }
        );

        addresses = query;
      } catch (e) {
        console.error(e);
        return [];
      }
    } else {
      const query = await sequelize.query(
        `
        SELECT TOP 10
            a.*, 
            district.ENGLISH_DESCRIPTION AS district_e, 
            district.CHINESE_DESCRIPTION AS district_c,
            (SELECT ENGLISH_DESCRIPTION AS region_e FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.SYS_REGION_ID) AS region_e,
            (SELECT CHINESE_DESCRIPTION AS region_c FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.SYS_REGION_ID) AS region_c,
            area.ENGLISH_DESCRIPTION AS area_e,
            area.CHINESE_DESCRIPTION AS area_c,
            (SELECT ENGLISH_DESCRIPTION AS bt_e FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.BLK_TYPE_ID) AS bt_e,
            (SELECT CHINESE_DESCRIPTION AS bt_c FROM Sys_Meta_Data WHERE SYS_META_DATA_ID = a.BLK_TYPE_ID) AS bt_c
      
        FROM AdrBlk a
        LEFT JOIN Sys_Meta_Data district 
          ON a.SYS_DISTRICT_ID = district.SYS_META_DATA_ID
        LEFT JOIN Sys_Meta_Data area 
          ON a.AREA_ID = area.SYS_META_DATA_ID
        WHERE (
            a.BLDG_NAME_E1 LIKE :buildingName
            OR a.BLDG_NAME_E2 LIKE :buildingName
            OR a.BLDG_NAME_E3 LIKE :buildingName
            OR a.BLDG_NAME_C1 LIKE :buildingName
            OR a.BLDG_NAME_C2 LIKE :buildingName
            OR a.BLDG_NAME_C3 LIKE :buildingName
        ) AND (
            a.OSADR_ST_E1 LIKE :streetName
            OR a.OSADR_ST_E2 LIKE :streetName
            OR a.OSADR_ST_C LIKE :streetName
        ) AND (
            a.OSADR_LOT_E1 LIKE :dd
            OR a.OSADR_LOT_E2 LIKE :dd
            OR a.OSADR_LOT_E3 LIKE :dd
            OR a.OSADR_LOT_E4 LIKE :dd
            OR a.OSADR_LOT_C1 LIKE :dd
            OR a.OSADR_LOT_C2 LIKE :dd
            OR a.OSADR_LOT_C3 LIKE :dd
            OR a.OSADR_LOT_C4 LIKE :dd
        ) AND (
            a.OSADR_LOT_E1 LIKE :lot
            OR a.OSADR_LOT_E2 LIKE :lot
            OR a.OSADR_LOT_E3 LIKE :lot
            OR a.OSADR_LOT_E4 LIKE :lot
            OR a.OSADR_LOT_C1 LIKE :lot
            OR a.OSADR_LOT_C2 LIKE :lot
            OR a.OSADR_LOT_C3 LIKE :lot
            OR a.OSADR_LOT_C4 LIKE :lot
        ) AND a.OBSOLETE = 'N'
  
        `,
        {
          replacements: {
            buildingName: `%${BuildingName}%`,
            streetName: `%${StreetName}%`,
            dd: `%${DD}%`,
            lot: `%${Lot}%`,
          },
          type: QueryTypes.SELECT,
        }
      );

      addresses = query;
    }
    let response = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: camelize(addresses),
    };
    return res.status(200).json(response);
  } catch (err) {
    next(err);
  }
});

router.post("/checkschoolappstatus", async (req, res, next) => {
  try {
    const applicationNo = req.query.appNo;
    const formName = req.query.formName;
    const successResponse = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        applicationNo: applicationNo,
        formName: formName,
        status: "Submitted",
      },
    };
    return res.status(200).json(successResponse);
  } catch (err) {
    next(err);
  }
});

router.get("/unsynced-submissions", async (req, res, next) => {
  try {
    const submissions = await SchoolAppSubmissionModel.findAll({
      where: { Synced: false, Status: "Submitted" },
      raw: true, // This ensures Sequelize does not format the results and keeps the original data types.
      limit: 5, // Limit the number of results to 10
    });
    const submissionIds = submissions.map((submission) => submission.Id);
    console.log("Getting unsynced submissions", submissionIds);
    // Mark the submissions as synced
    await SchoolAppSubmissionModel.update(
      { Synced: true },
      { where: { Id: submissionIds } }
    );

    return res.status(200).json(
      submissions.map((submission) => {
        try {
          if (submission.ApList)
            submission.APP13 = JSON.parse(submission.ApList);
          if (submission.SelfCertification)
            submission.SelfCertification = JSON.parse(
              submission.SelfCertification
            );
        } catch (e) {}
        return submission;
      })
    );
  } catch (err) {
    console.log(err);
    next(err);
  }
});

router.post(
  "/backend-update",
  upload.single("file"),
  async (req, res, next) => {
    try {
      const { applicationNo, stage, updateType } = req.body;
      console.log("Update Body", req.body);
      let newUpdate = {
        ApplicationNo: applicationNo,
        Stage: stage,
        UpdateType: updateType,
      };
      console.log("Update File", req.file);

      if (req.file) {
        let fileObj = req.file;
        newUpdate.FileMimeType = req.file.mimetype;
        delete fileObj.mimetype;
        newUpdate.File = JSON.stringify(fileObj);
      }

      const backendUpdate = await BackendUpdateModel.create(newUpdate);
      if (stage) {
        await SchoolAppInfoModel.update(
          { Stage: stage },
          { where: { ApplicationNo: applicationNo } }
        );
      }
      if (!backendUpdate) {
        return res.status(400).json({ error: "Update failed" });
      }
      const successResponse = {
        meta: {
          code: 200,
          message: "OK",
        },
        data: {
          updateId: backendUpdate.dataValues.Id,
        },
      };
      return res.status(200).json(successResponse);
    } catch (err) {
      next(err);
    }
  }
);

module.exports = router;

================
File: bd-scs-nodejs-frontend-main/src/routes/AuthController.js
================
var express = require("express");
const axios = require("axios");
var router = express.Router();
const GenOtpModel = require("../models/GenOtp");
const { getUserJsonWithToken } = require("../utils/loginUtils");
const ScsMasterTableModel = require("../models/ScsMasterTable");
const sendEmail = require("../utils/sendEmail");

router.post("/getUserLoginWithToken", async (req, res, next) => {
  try {
    const user = await getUserJsonWithToken(req.body);
    if (user) {
      const successResponse = {
        meta: {
          code: 200,
          message: "OK",
        },
        data: {
          userId: user.userId,
          role: user.role,
          token: user.token,
        },
      };
      res.status(200).json(successResponse);
    } else {
      const errorResponse = {
        meta: {
          code: 400,
          message: "Invalid applicationNo or userId",
        },
        data: {},
      };
      res.status(400).json(errorResponse);
    }
  } catch (err) {
    next(err);
  }
});

router.post("/getotp", async (req, res, next) => {
  try {
    const { applicationNo, userId } = req.body;
    await GenOtpModel.destroy({
      where: {
        ApplicationNo: applicationNo,
        UserId: userId,
      },
    });
    const randomNumber = Math.floor(Math.random() * (999999 - 100000 + 1)) + 100000;
    const currentDate = new Date();
    const newOtp = await GenOtpModel.create({
      ApplicationNo: applicationNo,
      UserId: userId,
      Otp: randomNumber,
      EffectiveUntil: new Date(currentDate.getTime() + 5 * 60000),
      Used: 0,
    });
    if (!newOtp) {
      return res.status(400).json({ error: "Create application fail" });
    }
    if (/^\d+$/.test(userId)) {
      // Generate SMS message
      let message = "";
      const query = await ScsMasterTableModel.findOne({
          where: { Type: "otp_login_msg", Code: "sms_message" },
      });

      message = query?.CaptionEN || ""; // Default to English
      message = message.replace("[otp]", randomNumber);
      console.log(message);
      // Send SMS
      const smsUserName = "BDSCS24"; // Replace with your SMS service username
      const smsPassword = "SDFU4XF"; // Replace with your SMS service password

      // Build URL
      const url = `https://www.mdtechcorp.com/openapi/?username=${smsUserName}&password=${smsPassword}&destinatingAddress=852${userId.trim()}&sms=${message
      }&type=1`;

      try {
          // Make GET request
          const response = await axios.get(url);
          console.log("SMS sent successfully:", response.data);
      } catch (error) {
          console.error("Error sending SMS:", error.message);
          throw error; // Rethrow error for the caller to handle
      }

    } else {
        // Send Email
        // Fetch email subject and body from database
        const query = await ScsMasterTableModel.findOne({
            where: { Type: "otp_login_msg", Code: "email_message" },
        });

        const subject = query?.CaptionEN || ""; // Default to English
        let body = query?.LongTextEN || ""; // Default to English

        body = body.replace("[otp]", randomNumber);

        // Fetch OTP effective time from database
        const effectiveQuery = await ScsMasterTableModel.findOne({
            where: { Type: "admin_setting", Code: "otp_effective_min" },
        });

        const effectiveMin = effectiveQuery?.DataValue || "";
        body = body.replace("[effective_min]", effectiveMin);

        // Send Email
        await sendEmail(
            userId,
            subject,
            body,
        );
    }
    const successResponse = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        result: "One Time Password (OTP) has been generated.",
      },
    };
    res.status(200).json(successResponse);
  } catch (err) {
    next(err);
  }
});

router.post("/getotp-bysms", async (req, res, next) => {
  try {
    const mobile = req.query.mobile.trim();
    await GenOtpModel.destroy({
      where: {
        UserId: mobile,
      },
    });
    const randomNumber = Math.floor(Math.random() * (999999 - 100000 + 1)) + 100000;
    const currentDate = new Date();
    const newOtp = await GenOtpModel.create({
      ApplicationNo: "",
      UserId: mobile,
      Otp: randomNumber,
      EffectiveUntil: new Date(currentDate.getTime() + 5 * 60000),
      Used: 0,
    });
    if (!newOtp) {
      return res.status(400).json({ error: "Create application fail" });
    }
    // Generate SMS message
    let message = "";
    const query = await ScsMasterTableModel.findOne({
        where: { Type: "otp_login_msg", Code: "sms_message" },
    });

    message = query?.CaptionEN || ""; // Default to English
    message = message.replace("[otp]", randomNumber);
    // check mobile is email address or not
    if (mobile.includes("@")) {
      // Send Email
      await sendEmail(mobile, "OTP", message);
    } else {
      // Send SMS
      const smsUserName = "BDSCS24"; // Replace with your SMS service username
      const smsPassword = "SDFU4XF"; // Replace with your SMS service password

      // Build URL
      const url = `https://www.mdtechcorp.com/openapi/?username=${smsUserName}&password=${smsPassword}&destinatingAddress=852${mobile.trim()}&sms=${message
      }&type=1`;

      try {
          // Make GET request
          const response = await axios.get(url);
          console.log("SMS sent successfully:", response.data);
      } catch (error) {
          console.error("Error sending SMS:", error.message);
          throw error; // Rethrow error for the caller to handle
      }
    }

    const successResponse = {
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        result: "One Time Password (OTP) has been generated.",
      },
    };
    res.status(200).json(successResponse);
  } catch (err) {
    next(err);
  }
});

router.post("/otp-verification", async (req, res, next) => {
  try {
    const { applicationNo, userId, verificationCode } = req.body;
    await GenOtpModel.findOne({
      where: {
        ApplicationNo: applicationNo,
        UserId: userId,
      },
    }).then(async (otp) => {
      if (otp) {
        if (otp.Otp === verificationCode && new Date() < otp.EffectiveUntil) {
          await GenOtpModel.destroy({
            where: {
              ApplicationNo: applicationNo,
              UserId: userId,
            },
          });
          res.status(200).json({
            meta: {
              code: 200,
              message: "OK",
            },
            data: {
              result: "Verification success",
            },
          });
        } else {
          res.status(400).json({
            meta: {
              code: 400,
              message: "Invalid verification code",
            },
            data: {},
          });
        }
      } else {
        res.status(400).json({
          meta: {
            code: 400,
            message: "Invalid applicationNo or userId",
          },
          data: {},
        });
      }
    });
  } catch (err) {
    next(err);
  }
})

router.post("/sendverifyotpbysms", async (req, res, next) => {
  try {
    const mobile = req.query.mobile.trim();
    const code = req.query.code.trim();
    const otp = await GenOtpModel.findOne({
      where: {
        UserId: mobile,
      },
    });
    if (otp) {
      if (otp.Otp === code && new Date() < otp.EffectiveUntil) {
        await GenOtpModel.destroy({
          where: {
            UserId: mobile,
          },
        });
        res.status(200).json({
          meta: {
            code: 200,
            message: "OK",
          },
          data: {
            result: "Verification success",
          },
        });
      } else {
        res.status(400).json({
          meta: {
            code: 400,
            message: "Invalid verification code",
          },
          data: {},
        });
      }
    } else {
      res.status(400).json({
        meta: {
          code: 400,
          message: "Invalid mobile",
        },
        data: {},
      });
    }
  } catch (err) {
    next(err);
  }
});
module.exports = router;

================
File: bd-scs-nodejs-frontend-main/src/routes/ESignController.js
================
var express = require("express");
var router = express.Router();
const IamSmartModel = require("../models/IamSmart");
const sequelize = require("../config/database");
const multer = require("multer");
const { hkpostSign } = require("../utils/hkpostUtils");
const upload = multer({ dest: "temp_uploads/" });
const {
  initiateIamsmartRequest,
  getAccessTokenOpenID,
  getSignResult,
  insertSignature,
} = require("../utils/iamSmartUtils");

function toCamelCase(string) {
  return string[0].toLowerCase() + string.slice(1);
}

// IAM Smart API
// {
//     "fileId": "cce60e12-a7ef-4085-87b0-bb154274e72c",
//     "hkic": "G538200",
//     "documentName": "cce60e12-a7ef-4085-87b0-bb154274e72c.pdf",
//     "lang": "en-US"
// }

router.post("/hkpost", upload.single("certFile"), async (req, res, next) => {
  try {
    const { fileId, certPassword } = req.body;

    const file = await hkpostSign(fileId, req.file.path, certPassword);

    const fileRes = Object.keys(file).reduce((acc, cur) => {
      acc[toCamelCase(cur)] = file[cur];
      return acc;
    }, {});

    res.status(200).json({
      meta: {
        code: 200,
        message: "OK",
      },
      data: fileRes,
    });
  } catch (err) {
    next(err);
  }
});

router.post("/iamsmart", async (req, res, next) => {
  try {
    const { fileId, hkic, documentName, lang, currentUrl } = req.body;

    const { signCode, qrcodeUrl } = await initiateIamsmartRequest(
      fileId,
      hkic,
      documentName,
      lang,
      currentUrl
    );
    res.status(200).json({
      meta: {
        code: 200,
        message: "OK",
      },
      data: {
        signCode,
        qrcodeUrl,
      },
    });
  } catch (err) {
    next(err);
  }
});

router.get("/iamsmart/callback", async (req, res, next) => {
  try {
    const { code, state, businessID, error_code } = req.query;
    console.log("Callback res", req.query);
    if (error_code) {
      const file = (
        await sequelize.query(
          `SELECT * FROM IamSmart I INNER JOIN ApplicationFiles A ON I.FileId = A.FileId WHERE I.BusinessId = '${businessID}'`
        )
      )[0][0];
      const currentUrl = file.CurrentUrl
      if (currentUrl.includes("?")) {
        if (currentUrl.includes("&msg")) {
          const modifyUrl = currentUrl.split("&msg")[0];
          return res.redirect(modifyUrl + "&msg=" + error_code);
        }
        return res.redirect(currentUrl + "&msg=" + error_code);
      } else {
        return res.redirect(currentUrl + "?msg=" + error_code);
      }
      
    } 

    const { accessToken, openID } = await getAccessTokenOpenID(code);
    const signature = await getSignResult(accessToken, openID);
    const currentUrl = await insertSignature(businessID, signature);
    if (currentUrl.includes("&msg")) {
      const modifyUrl = currentUrl.split("&msg")[0];
      return res.redirect(modifyUrl);
    }
    return res.redirect(currentUrl);
  } catch (err) {
    next(err);
  }
});

module.exports = router;

================
File: bd-scs-nodejs-frontend-main/src/services/IamSmartServices.js
================
const getQRCodePage = async (fileId, hkic, documentName, lang) => {};

================
File: bd-scs-nodejs-frontend-main/src/tests/initializeDatabase.js
================
const { Sequelize } = require("sequelize");

const sequelize = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASSWORD,
  {
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
  }
);

sequelize.authenticate().then(() => {
  console.log("Connection has been established successfully.");
});

================
File: bd-scs-nodejs-frontend-main/src/tests/testAdrBlk.js
================
const AdrBlkModel = require("../models/AdrBlk");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await AdrBlkModel.create({
      ADR_BLK_ID: 1,
      BLK_TYPE_ID: 1,
      BLDG_CAT_ID: 1,
      BLDG_USAGE_ID: 1,
      SYS_REGION_ID: 1,
      SYS_DISTRICT_ID: 1,
      AREA_ID: 1,
      BLK_DESC_E_ID: 1,
      BLK_NO_NUM: 123,
      BLK_NO_ALPHA: "A",
      BLDG_NAME_E1: "Building 1",
      BLDG_NAME_E2: "Building 2",
      BLDG_NAME_E3: "Building 3",
      BLDG_NAME_C1: "Building 1",
      BLDG_NAME_C2: "Building 2",
      BLDG_NAME_C3: "Building 3",
      OSADR_E1: "Address 1",
      OSADR_E2: "Address 2",
      OSADR_E3: "Address 3",
      OSADR_E4: "Address 4",
      OSADR_E5: "Address 5",
      OSADR_ST_E1: "Street 1",
      OSADR_ST_E2: "Street 2",
      OSADR_LOT_E1: "Lot 1",
      OSADR_LOT_E2: "Lot 2",
      OSADR_LOT_E3: "Lot 3",
      OSADR_LOT_E4: "Lot 4",
      OSADR_ST_C: "Street",
      OSADR_LOT_C1: "Lot 1",
      OSADR_LOT_C2: "Lot 2",
      OSADR_LOT_C3: "Lot 3",
      OSADR_LOT_C4: "Lot 4",
      OSADR_C1: "Address 1",
      OSADR_C2: "Address 2",
      OSADR_C3: "Address 3",
      OSADR_C4: "Address 4",
      OSADR_C5: "Address 5",
      OBSOLETE: "No",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await AdrBlkModel.findOne({
      where: { OBSOLETE: "No" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testApplicationCase.js
================
const ApplicationCaseModel = require("../models/ApplicationCase");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await ApplicationCaseModel.create({
      FromId: 1,
      ApplicationNo: "AppNo123",
      FileDate: new Date(),
      CreatedBy: "Admin",
      UpdatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await ApplicationCaseModel.findOne({
      where: { ApplicationNo: "AppNo123" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testApplicationFile.js
================
const ApplicationFileModel = require("../models/ApplicationFile");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await ApplicationFileModel.create({
      FromId: 2,
      ApplicationNo: "AppNo123",
      SubmissionId: "SubId123",
      FileId: "FileId123",
      FileName: "File1",
      FileSize: 123456,
      DocumentType: "PDF",
      SignDate: new Date(),
      SignType: "Digital",
      FilePath: "/path/to/file",
      FileDate: new Date(),
      RemoveStatus: "No",
      CreatedBy: "Admin",
      UpdatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await ApplicationFileModel.findAll();
    console.log("Fetched entry:", fetchedEntry.toJSON());
    // console.log(
    //   fetchedEntry.every((user) => user instanceof ApplicationFileModel)
    // ); // true
    // console.log("All users:", JSON.stringify(fetchedEntry, null, 2));
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testApRse.js
================
const ApRseModel = require("../models/ApRse");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await ApRseModel.create({
      UUID: "UUID123",
      Name: "Name123",
      Name_tc: "NameTC123",
      RegistrationNumber: "RegNo123",
      RegistrationType: "RegType123",
      ExpiryDate: new Date(),
      CreatedBy: "Admin",
      UpdatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await ApRseModel.findOne({
      where: { RegistrationNumber: "RegNo123" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testGenOtp.js
================
const GenOtpModel = require("../models/GenOtp");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await GenOtpModel.create({
      ApplicationNo: "AppNo123",
      UserId: "User123",
      Otp: "123456",
      Used: 0,
      EffectiveUntil: new Date(),
      CreatedBy: "Admin",
      UpdatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await GenOtpModel.findOne({
      where: { UserId: "User123" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testLogEvents.js
================
const LogEventsModel = require("../models/LogEvents");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await LogEventsModel.create({
      LogAlias: "Alias123",
      IpAddress: "129.1.2.0",
      PlatformId: 1,
      FromUrl: "FromUrl123",
      CallUrlApi: "CallUrl",
      StatusCode: "200",
      LoginInfo: "LoginInfo123",
      RequestBody: "RequestBody123",
      Response: "Response123",
      PrgError: "PrgError123",
      CreatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await LogEventsModel.findOne({
      where: { FromUrl: "FromUrl123" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testSchoolAppInfo.js
================
const SchoolAppInfoModel = require("../models/SchoolAppInfo");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await SchoolAppInfoModel.create({
      FromId: 1,
      ApplicationNo: "APP-001",
      SubmissionId: "SUB-001",
      FormName: "Application Form",
      ApplicationType: "New",
      ApplicantAddress: "123 Main St, City",
      ApplicantName: "John Doe",
      ApplicantEmail: "johndoe@example.com",
      ApplicantMobile: "1234567890",
      ContactPName: "Jane Doe",
      ContactPEmail: "johndoe@example.com",
      ContactPMobile: "1234567890",
      ContactPTel: "1234567890",
      ContactPFax: "1234567890",
      Date: "2021-08-01",
      AddressOfPremiseCN: "123 Main St, City",
      AddressOfPremiseEN: "123 Main St, City",
      NameOfSchoolCN: "ABC School",
      NameOfSchoolEN: "ABC School",
      DescriptionOfSchool: "Description of ABC School",
      AgeOfStudent: "Primary",
      EstimatedNoOfStudent: 100,
      Sign: "John Doe",
      ChineseNameOfAp1: "Jane Doe",
      EnglishNameOfAp1: "Jane Doe",
      EmailOfAp1: "johndoe@example.com",
      MobileOfAp1: "1234567890",
      RegTypeOfAp1: "Type A",
      CertRegNoOfAp1: "CERT-001",
      ChineseNameOfAp2: "Jane Doe",
      EnglishNameOfAp2: "Jane Doe",
      EmailOfAp2: "janedoe@example.com",
      MobileOfAp2: "1234567890",
      RegTypeOfAp2: "Type A",
      CertRegNoOfAp2: "CERT-002",
      ChineseNameOfRse: "Jane Doe",
      EnglishNameOfRse: "Jane Doe",
      EmailOfRse: "janedoe@example.com",
      MobileOfRse: "1234567890",
      RegTypeOfRse: "Type A",
      CertRegNoOfRse: "CERT-003",
      Status: "Submitted",
      SubmittedDate: "2021-08-01",
      InspectReq: 0,
      WithdrawReq: 0,
      BDLetterRefDate: "2021-08-01",
      BDLetterRefNo: "REF-001",
      SubmitRefDate: "2021-08-01",
      ApplicantPostTitle: "Director",
      ApplicantAddressEN: "123 Main St, City",
      ApplicantTitle: "Mr.",
      ApplicantNameEN: "John Doe",
      ApplicantHKIC: "HKID-001",
      ApplicantTel: "1234567890",
      ApplicantRepOrg: "ABC Organization",
      ApplicantRepOrgEN: "ABC Organization",
      ContactPAddress: "123 Main St, City",
      ContactPTitle: "Ms.",
      PhoneOfSchool: "1234567890",
      ApplicantRefDate: "2021-08-01",
      FileDate: "2021-08-01",
      DateOfInspection: "2021-08-01",
      ApplicantDated: "2021-08-01",
      Category1Requirement: "Requirement 1",
      Category2Requirement: "Requirement 2",
      RegExpiryDateOfAp2: "2021-08-01",
      FaxOfAp2: "1234567890",
      AddressOfAp2: "123 Main St, City",
      IdentityOfAp2: "ID-001",
      CreatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await SchoolAppInfoModel.findOne({
      where: { ApplicantEmail: "johndoe@example.com" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testSchoolAppSubmission.js
================
const SchoolAppSubmissionModel = require("../models/SchoolAppSubmission");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await SchoolAppSubmissionModel.create({
      FromId: 1,
      ApplicationNo: "APP-001",
      SubmissionId: "SUB-001",
      FormName: "Application Form",
      ApplicationType: "New",
      ApplicantAddress: "123 Main St, City",
      ApplicantName: "John Doe",
      ApplicantEmail: "johndoe@example.com",
      ApplicantMobile: "1234567890",
      ContactPName: "Jane Doe",
      ContactPEmail: "johndoe@example.com",
      ContactPMobile: "1234567890",
      ContactPTel: "1234567890",
      ContactPFax: "1234567890",
      Date: "2021-08-01",
      AddressOfPremiseCN: "123 Main St, City",
      AddressOfPremiseEN: "123 Main St, City",
      NameOfSchoolCN: "ABC School",
      NameOfSchoolEN: "ABC School",
      DescriptionOfSchool: "Description of ABC School",
      AgeOfStudent: "Primary",
      EstimatedNoOfStudent: 100,
      Sign: "John Doe",
      ChineseNameOfAp1: "Jane Doe",
      EnglishNameOfAp1: "Jane Doe",
      EmailOfAp1: "johndoe@example.com",
      MobileOfAp1: "1234567890",
      RegTypeOfAp1: "Type A",
      CertRegNoOfAp1: "CERT-001",
      ChineseNameOfAp2: "Jane Doe",
      EnglishNameOfAp2: "Jane Doe",
      EmailOfAp2: "janedoe@example.com",
      MobileOfAp2: "1234567890",
      RegTypeOfAp2: "Type A",
      CertRegNoOfAp2: "CERT-002",
      ChineseNameOfRse: "Jane Doe",
      EnglishNameOfRse: "Jane Doe",
      EmailOfRse: "janedoe@example.com",
      MobileOfRse: "1234567890",
      RegTypeOfRse: "Type A",
      CertRegNoOfRse: "CERT-003",
      Status: "Submitted",
      SubmittedDate: "2021-08-01",
      InspectReq: 0,
      WithdrawReq: 0,
      BDLetterRefDate: "2021-08-01",
      BDLetterRefNo: "REF-001",
      SubmitRefDate: "2021-08-01",
      ApplicantPostTitle: "Director",
      ApplicantAddressEN: "123 Main St, City",
      ApplicantTitle: "Mr.",
      ApplicantNameEN: "John Doe",
      ApplicantHKIC: "HKID-001",
      ApplicantTel: "1234567890",
      ApplicantRepOrg: "ABC Organization",
      ApplicantRepOrgEN: "ABC Organization",
      ContactPAddress: "123 Main St, City",
      ContactPTitle: "Ms.",
      PhoneOfSchool: "1234567890",
      ApplicantRefDate: "2021-08-01",
      FileDate: "2021-08-01",
      RemoveStatus: "Active",
      DateOfInspection: "2021-08-01",
      ApplicantDated: "2021-08-01",
      Category1Requirement: "Requirement 1",
      Category2Requirement: "Requirement 2",
      RegExpiryDateOfAp2: "2021-08-01",
      FaxOfAp2: "1234567890",
      AddressOfAp2: "123 Main St, City",
      IdentityOfAp2: "ID-001",
      CreatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await SchoolAppSubmissionModel.findOne({
      where: { ApplicantEmail: "johndoe@example.com" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testScsMasterTable.js
================
const ScsMasterTableModel = require("../models/ScsMasterTable");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await ScsMasterTableModel.create({
      Type: "Type A",
      Code: "CODE-001",
      Ordering: 1,
      DataValue: "Data Value 1",
      CaptionEN: "Caption in English",
      CaptionTC: "Caption in Traditional Chinese",
      CaptionSC: "Caption in Simplified Chinese",
      Remarks: "Remarks",
      LongTextEN: "Long text in English",
      LongTextTC: "Long text in Traditional Chinese",
      LongTextSC: "Long text in Simplified Chinese",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await ScsMasterTableModel.findOne({
      where: { Code: "CODE-001" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testSMTP.js
================
const nodemailer = require("nodemailer");

nodemailer.createTransport({
  host: "smtpx.cis.hksarg",
  port: 587,
  secure: true, // use TLS

  tls: {
    // do not fail on invalid certs
    rejectUnauthorized: false,
  },
});

// Test email

// verify connection configuration
transporter.verify(function (error, success) {
  if (error) {
    console.log(error);
  } else {
    console.log("Server is ready to take our messages");
  }
});

================
File: bd-scs-nodejs-frontend-main/src/tests/testStaff.js
================
const StaffModel = require("../models/Staff");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await StaffModel.create({
      UserId: "UserId123",
      Password: "Password123",
      EnglishName: "EnglishName123",
      ChineseName: "ChineseName123",
      Department: "Department123",
      Post: "Post123",
      Telephone: "Telephone123",
      Email: "Email123",
      Role: "Role123",
      Status: 1,
      CreatedBy: "Admin",
      UpdatedBy: "Admin",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await StaffModel.findOne({
      where: { UserId: "UserId123" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testSysMetaDataModel.js
================
const SysMetaDataModel = require("../models/Sys_Meta_Data");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    const { DataTypes, Model } = require("sequelize");
    // Creating a new entry
    const testEntry = await SysMetaDataModel.create({
      REC_TYPE: "REC_TYPE",
      CODE: "CODE",
      PARENT_ID: 1,
      ENGLISH_DESCRIPTION: "English Description",
      CHINESE_DESCRIPTION: "Chinese Description",
      IS_ACTIVE: "Y",
      ORDERING: 1,
      CREATED_DT: new Date(),
      CREATED_POST: "Post",
      CREATED_NAME: "Name",
      CREATED_SECTION: "Section",
      LAST_MODIFIED_DT: new Date(),
      LAST_MODIFIED_POST: "Post",
      LAST_MODIFIED_NAME: "Name",
      LAST_MODIFIED_SECTION: "Section",
      MULTI_INSP_FOR_LSO_IND: "Y",
      REC_SRC: "REC_SRC",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await SysMetaDataModel.findOne({
      where: { REC_SRC: "REC_SRC" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/tests/testTestModel.js
================
const TestModel = require("../models/test");
const sequelize = require("../config/database");

async function runTest() {
  try {
    // Sync the model with the database
    await sequelize.sync({ force: false }); // Drops the table if it already exists and recreates it

    // Creating a new entry
    const testEntry = await TestModel.create({
      name: "John Doe",
      age: 25,
      email: "johndoe@example.com",
    });

    console.log("Entry created:", testEntry.toJSON());

    // Fetching the entry
    const fetchedEntry = await TestModel.findOne({
      where: { email: "johndoe@example.com" },
    });
    console.log("Fetched entry:", fetchedEntry.toJSON());
  } catch (error) {
    console.error("Error occurred:", error);
  } finally {
    await sequelize.close(); // Close the connection after the test
  }
}

runTest();

================
File: bd-scs-nodejs-frontend-main/src/utils/aes256gcm.js
================
const crypto = require("crypto");

const IV_LENGTH = 12;

const aes256gcm = (key) => {
  const encrypt = (str) => {
    const iv = new crypto.randomBytes(IV_LENGTH);
    const cipher = crypto.createCipheriv("aes-256-gcm", key, iv);

    // Set tag length to 16 bytes

    // Hint: Larger inputs (it's GCM, after all!) should use the stream API
    let enc1 = cipher.update(str);
    let enc2 = cipher.final();
    // Convert iv.length to 4 bytes
    const ivLength = Buffer.alloc(4);
    ivLength.writeUInt32BE(IV_LENGTH, 0);
    console.log(
      Buffer.concat([ivLength, iv, enc1, cipher.getAuthTag()]).length
    );
    return Buffer.concat([ivLength, iv, enc1, cipher.getAuthTag()]).toString(
      "base64"
    );
  };

  const decrypt = (enc) => {
    enc = Buffer.from(enc, "base64");
    const iv = enc.slice(4, 4 + IV_LENGTH);

    const tag = enc.slice(enc.length - 16);
    const decipher = crypto.createDecipheriv("aes-256-gcm", key, iv);
    decipher.setAuthTag(tag);
    const str = decipher.update(enc.slice(4 + IV_LENGTH, enc.length - 16));

    return str.toString("utf8");
  };

  return {
    encrypt,
    decrypt,
  };
};

module.exports = aes256gcm;

================
File: bd-scs-nodejs-frontend-main/src/utils/applicationUtils.js
================
const SchoolAppSubmissionModel = require("../models/SchoolAppSubmission");
const { Op } = require("sequelize");

const APPLICATION_NO_TYPES = {
  NEWSCH: 12,
  EXTSCH: 12,
  NLHE: 12,
  NEWCCC: 13,
  NEWJOKC: 13,
  NEWMUT: 13,
};

async function generateApplicationNo(applicationType) {
  console.log("generateApplicationNo", applicationType);
  const year = new Date().getFullYear();
  if (!Object.keys(APPLICATION_NO_TYPES).includes(applicationType)) {
    return null;
  }
  const type = APPLICATION_NO_TYPES[applicationType];

  // Create a regex pattern to match application numbers starting with FYYYYTT
  const regexPattern = `F${year}${type}%`;

  // Query to find the last application matching the pattern
  try {
    const lastApplication = await SchoolAppSubmissionModel.findOne({
      where: {
        ApplicationNo: {
          [Op.like]: regexPattern, // For case-insensitive regex in Sequelize
        },
      },
      order: [["ApplicationNo", "DESC"]], // Sort in descending order to get the latest entry
    });

    let count = 1; // Start from 1 if no previous applications are found
    if (lastApplication) {
      // Extract the count from the last application's number
      const lastCount = parseInt(lastApplication.ApplicationNo.slice(-5));
      count = lastCount + 1;
    }
    console.log("count", count);
    const paddedCount = count.toString().padStart(5, "0");
    const newApplicationNo = `F${year}${type}${paddedCount}`;

    return newApplicationNo;
  } catch (error) {
    console.log(error);
    return null;
  }
}

module.exports = { generateApplicationNo };

================
File: bd-scs-nodejs-frontend-main/src/utils/ExternalSigner.js
================
/* eslint-disable no-unused-vars */
import * as nodeCrypto from 'crypto';
import * as asn1js from 'asn1js';
import * as pkijs from 'pkijs';
import {ISigner, SignPdfError} from '@signpdf/utils';
import {Signer} from "./Signer"

/**
 * Abstract ExternalSigner class taking care of creating a suitable signature for a given pdf
 * using an external signature provider.
 * Subclasses should specify the required signature and hashing algorithms used by the external
 * provider (either through the `signAlgorithm` and `hashAlgorithm` attributes, or by overriding
 * the `getSignAlgorithm` and `getHashAlgorithm` methods), as well as provide the used signing
 * certificate and final signature (by implementing the `getCertificate` and `getSignature`
 * methods).
 */
export class ExternalSigner extends Signer {
    /**
     * Method to retrieve the signature of the given hash (of the given data) from the external
     * service. The original data is included in case the external signature provider computes
     * the hash automatically before signing.
     * To be implemented by subclasses.
     * @param {Uint8Array} hash
     * @param {Uint8Array} data
     * @returns {Promise<Uint8Array>}
     */
    async getSignature(hash, data) {
        throw new SignPdfError(
            `getSignature() is not implemented on ${this.constructor.name}`,
            SignPdfError.TYPE_INPUT,
        );
    }

    /**
     * Get a "crypto" extension and override the function used by SignedData.sign to support
     * external signing.
     * @returns {pkijs.ICryptoEngine}
     */
    getCrypto() {
        const crypto = super.getCrypto();
        crypto.sign = async (_algo, _key, data) => {
            // Calculate hash
            const hash = await crypto.digest({name: this.hashAlgorithm}, data);
            // And pass it to the external signature provider
            const signature = await this.getSignature(Buffer.from(hash), Buffer.from(data));
            return signature;
        };
        return crypto;
    }

    /**
     * Obtain a dummy private key to pass the correct signing parameters to the sign function.
     * @returns {CryptoKey}
     */
    async obtainKey() {
        // The algorithm parameters cannot be passed directly to the SignedData.sign function, so we
        // need to generate a dummy private key with the required parameters and pass that to the
        // sign function. The private key is not actually used for signing, as we override the
        // crypto.sign function in the getCrypto method.
        const algorithmParams = this.crypto.getAlgorithmParameters(this.signAlgorithm, 'generatekey').algorithm;
        const keypair = await this.crypto.generateKey({
            name: this.signAlgorithm,
            ...algorithmParams,
            hash: {name: this.hashAlgorithm},
        }, false, ['sign', 'verify']);
        return keypair.privateKey;
    }
}

================
File: bd-scs-nodejs-frontend-main/src/utils/hkpostUtils.js
================
const { signWithPlaceholder } = require("./signUtils");
const fs = require("fs");
var P12Signer = require("@signpdf/signer-p12").P12Signer;
const ApplicationFiles = require("../models/ApplicationFile");
const sequelize = require("../config/database");
const { signConfig } = require("./signConfig");
const MOMENT = require("moment");

const hkpostSign = async (fileId, certFilePath, certPassword) => {
  const certFile = fs.readFileSync(certFilePath);
  console.log(certFile.length, certPassword);
  var signer = new P12Signer(certFile, {
    passphrase: certPassword,
  });

  const UPLOAD_DIR = "wwwroot/uploads/";
  const targetFile = UPLOAD_DIR + fileId + ".pdf";

  const applicantName = (
    await sequelize.query(
      `SELECT SI.ApplicantName FROM ApplicationFiles AF JOIN SchoolApp_Infos SI ON AF.ApplicationNo = SI.ApplicationNo WHERE AF.FileId = '${fileId}'`
    )
  )[0][0]["ApplicantName"];

  const DocumentType = (
    await sequelize.query(
      `SELECT AF.DocumentType FROM ApplicationFiles AF JOIN SchoolApp_Submissions SS ON AF.SubmissionId = SS.SubmissionId WHERE AF.FileId = '${fileId}'`
    )
  )[0][0]["DocumentType"];

  let signType = "";
  if (DocumentType == "form") {
    signType = (
      await sequelize.query(
        `SELECT SS.FormName FROM ApplicationFiles AF JOIN SchoolApp_Submissions SS ON AF.SubmissionId = SS.SubmissionId WHERE AF.FileId = '${fileId}'`
      )
    )[0][0]["FormName"];
  } else if (DocumentType == "layout-plan") {
    // check pdf dimension
    const pdf = fs.readFileSync(targetFile);
    const pdfjs = await import("pdfjs-dist");
    const pdfData = new Uint8Array(pdf);
    const pdfDoc = await pdfjs.getDocument(pdfData).promise;
    const page = await pdfDoc.getPage(1);
    const viewport = page.getViewport({ scale: 1 });
    const pdfWidth = viewport.width;
    const pdfHeight = viewport.height;
    if (
      pdfHeight >= 595 &&
      pdfHeight <= 596 &&
      pdfWidth >= 841 &&
      pdfWidth <= 842
    ) {
      signType = "A4";
    } else {
      signType = "A3";
    }
  }
  const signX = signConfig[signType]?.x || 400;
  const signY = signConfig[signType]?.y || 200;
  const signPage = signConfig[signType]?.page || 0;
  await signWithPlaceholder(
    targetFile,
    targetFile,
    {
      signatureLength: 9932,
    },
    signer,
    {
      x: signX,
      y: signY,
      pageNo: signPage,
      fontSize: 12,
      displayText: "Signed By " + applicantName + " (hkpost)",
    }
  );
  const file = (
    await ApplicationFiles.update(
      {
        SignDate: MOMENT().format("YYYY-MM-DD  HH:mm:ss.0000000"),
        SignType: "hkpost",
      },
      {
        where: {
          FileId: fileId,
        },
        returning: true,
        plain: true,
      }
    )
  )[1]["dataValues"];

  return file;

  // sequelize.query(`UPDATE ApplicationFiles SET SignDate=GETDATE(), SignType=hkpost WHERE FileId=${fileId}`)
  // Open the file path and store the signature inside
};

module.exports = { hkpostSign };

================
File: bd-scs-nodejs-frontend-main/src/utils/iamSmartUtils.js
================
const axios = require("axios"); // Axios for HTTP requests
const crypto = require("crypto");
const fs = require("fs");
const forge = require("node-forge");
const NodeRSA = require("node-rsa");
const aes256gcm = require("./aes256gcm");
const querystring = require("querystring");
const IamSmartModel = require("../models/IamSmart");
const ApplicationFileModel = require("../models/ApplicationFile");
const ApplicationFiles = require("../models/ApplicationFile");
const sequelize = require("../config/database");
const {
  signWithPlaceholder,
  externalSign,
  prepareDocDigest,
  getSignCode,
} = require("./signUtils");
const { signPdf } = require("pdf-signatures");
const { signConfig } = require("./signConfig");
require("dotenv").config();
const MOMENT = require("moment");

function decryptWithPrivateKey(privateKey, encryptedData) {
  const keyRSA = new NodeRSA(privateKey, "private", {
    encryptionScheme: "pkcs1",
  });

  keyRSA.setOptions({ environment: "browser", encryptionScheme: "pkcs1" }); //By default it will use the node crypto library with the CVE
  return keyRSA.decrypt(encryptedData);
}

// Function to create an HMAC SHA256 signature
function createHmacSha256Signature(secret, data) {
  // Create HMAC SHA256 hash
  // console.log("Secret =", secret);
  const hmac = crypto.createHmac("sha256", secret);
  const hash = hmac.update(data).digest("base64");

  // URL encode the hash if needed
  const signature = encodeURIComponent(hash);
  return signature;
  // return crypto.createHmac("sha256", secret).update(data).digest("hex");
}

// Function to initialize the Axios client with the required headers
function initHttpClient(requestBodyJson) {
  const client = axios.create();
  const timeStamp = Date.now().toString(); // Get current time in milliseconds since epoch
  const nonce = crypto.randomUUID().replace(/-/g, ""); // Generate a nonce without dashes
  // Default headers
  const headers = {
    clientID: process.env.IAM_SMART_CLIENT_ID,
    signatureMethod: "HmacSHA256",
    timestamp: timeStamp,
    nonce: nonce,
  };

  // Construct the parameter string for signing
  let paramStr;
  if (requestBodyJson) {
    paramStr = `${headers.clientID}${headers.signatureMethod}${timeStamp}${nonce}${requestBodyJson}`;
  } else {
    paramStr = `${headers.clientID}${headers.signatureMethod}${timeStamp}${nonce}`;
  }

  // Generate the signature
  const signature = createHmacSha256Signature(
    process.env.IAM_SMART_CLIENT_SECRET,
    paramStr
  );

  // Add signature to headers
  headers.signature = signature;

  // Apply headers to Axios instance
  client.defaults.headers = headers;

  return client;
}

async function getKey() {
  const client = initHttpClient();
  const uri = process.env.IAM_SMART_DOMAIN + "api/v1/security/getKey";

  try {
    const response = await client.post(uri, null);

    let result = response.data;

    if (result.code !== "D00000") {
      // Handle the error according to your application needs
      return null;
    }

    // console.log("Response: ", result);

    return result;
  } catch (error) {
    console.error(error);
    // Handle exceptions if necessary
    return null;
  }
}

async function getCek() {
  const result = await getKey();

  if (result === null) {
    console.error("获取CEK失败");
    return;
  }

  const secretKeyBytes = Buffer.from(result.content.secretKey, "base64");

  const privateKeyFilePath = "src/config/iamsmart6.2.p12";
  const keyFile = fs.readFileSync(privateKeyFilePath, "binary");
  const p12Asn1 = forge.asn1.fromDer(keyFile);
  const p12 = forge.pkcs12.pkcs12FromAsn1(
    p12Asn1,
    process.env.IAM_SMART_CERT_PASSWORD
  );

  var keyBag = p12.getBags({ bagType: forge.pki.oids.pkcs8ShroudedKeyBag })[
    forge.pki.oids.pkcs8ShroudedKeyBag
  ][0];

  var privateKey = forge.pki.privateKeyToPem(keyBag.key);

  var certBag = p12.getBags({ bagType: forge.pki.oids.certBag })[
    forge.pki.oids.certBag
  ][0];
  const publicKey = forge.pki.publicKeyToPem(certBag.cert.publicKey);

  const cek = decryptWithPrivateKey(privateKey, secretKeyBytes);

  const encryptedData = crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_PADDING,
    },
    cek
  );

  const decryptedData2 = decryptWithPrivateKey(privateKey, encryptedData);

  return cek;
}

const encryptRequestBody = async (cek, body) => {
  // Encrypt the body using the CEK with
  // AES-256-GCM algorithm
  const aes = aes256gcm(cek);
  const encryptedBody = aes.encrypt(JSON.stringify(body));
  //   const encryptedBody = aes.encrypt("abcrtgrtgrtg");
  //   const encryptedBody = await aesGcmEncrypt(JSON.stringify(body), cek);
  return {
    ...body,
    content: encryptedBody,
  };
};

const decryptResponse = async (cek, response) => {
  // Decrypt the response's content
  const decryptedRes = aes256gcm(cek).decrypt(response);

  return JSON.parse(decryptedRes);
};

const getQRCodePage = async (ticketId, lang = "en-US") => {
  // Construct the query string parameters
  const queryParams = {
    clientID: process.env.IAM_SMART_CLIENT_ID,
    responseType: "code",
    source: "PC_Browser",
    redirectURI: encodeURIComponent(process.env.IAM_SMART_RedirectURI),
    scope: encodeURIComponent("eidapi_sign"),
    ticketID: ticketId,
    lang: lang,
    state: require("crypto").randomUUID(), // Equivalent to Guid.NewGuid().ToString() in C#
    brokerPage: "false",
  };

  // Construct the full URI with query parameters
  const qr_code_url = `${
    process.env.IAM_SMART_DOMAIN
  }api/v1/auth/getQR?${querystring.stringify(queryParams)}`;
  // Return the URI as a resolved promise
  return qr_code_url;
};

const initiateIamsmartRequest = async (
  fileId,
  hkic,
  documentName,
  lang,
  currentUrl
) => {
  const cek = await getCek();
  const uuid = require("uuid");
  const businessId = uuid.v4();
  try {
    await IamSmartModel.create({
      FileId: fileId,
      BusinessId: businessId,
      CurrentUrl: currentUrl,
    });
  } catch (err) {
    console.log(err);
  }
  const UPLOAD_DIR = "wwwroot/uploads/";
  const targetFile = UPLOAD_DIR + fileId + ".pdf";
  const applicantName = (
    await sequelize.query(
      `SELECT SI.ApplicantName FROM ApplicationFiles AF JOIN SchoolApp_Infos SI ON AF.ApplicationNo = SI.ApplicationNo WHERE AF.FileId = '${fileId}'`
    )
  )[0][0]["ApplicantName"];

  const DocumentType = (
    await sequelize.query(
      `SELECT AF.DocumentType FROM ApplicationFiles AF JOIN SchoolApp_Submissions SS ON AF.SubmissionId = SS.SubmissionId WHERE AF.FileId = '${fileId}'`
    )
  )[0][0]["DocumentType"];

  let signType = "";
  if (DocumentType == "form") {
    signType = (
      await sequelize.query(
        `SELECT SS.FormName FROM ApplicationFiles AF JOIN SchoolApp_Submissions SS ON AF.SubmissionId = SS.SubmissionId WHERE AF.FileId = '${fileId}'`
      )
    )[0][0]["FormName"];
  } else if (DocumentType == "layout-plan") {
    // check pdf dimension
    const pdf = fs.readFileSync(targetFile);
    const pdfjs = await import("pdfjs-dist");
    const pdfData = new Uint8Array(pdf);
    const pdfDoc = await pdfjs.getDocument(pdfData).promise;
    const page = await pdfDoc.getPage(1);
    const viewport = page.getViewport({ scale: 1 });
    const pdfWidth = viewport.width;
    const pdfHeight = viewport.height;
    if (
      pdfHeight >= 595 &&
      pdfHeight <= 596 &&
      pdfWidth >= 841 &&
      pdfWidth <= 842
    ) {
      signType = "A4";
    } else {
      signType = "A3";
    }
  }
  const signX = signConfig[signType]?.x || 400;
  const signY = signConfig[signType]?.y || 200;

  const pdfWithPlaceholder = await signWithPlaceholder(
    targetFile,
    targetFile,
    {
      signatureLength: 20998,
    },
    null,
    {
      x: signX,
      y: signY,
      pageNo: 0,
      fontSize: 12,
      displayText: "Signed By " + applicantName + " (iamsmart)",
    }
  );
  const docDigest = await prepareDocDigest(pdfWithPlaceholder);
  const hkicHash = require("crypto")
    .createHash("sha256")
    .update(hkic)
    .digest("base64");

  const DEPARTMENT = "Building Department";
  const SERVICE_NAME = "SCS";

  const req = {
    businessID: businessId,
    docDigest: docDigest,
    HKICHash: hkicHash,
    department: DEPARTMENT,
    serviceName: SERVICE_NAME,
    documentName: documentName,
  };

  const signCode = getSignCode(
    docDigest,
    hkicHash,
    process.env.IAM_SMART_CLIENT_ID
  );

  const encryptedReq = await encryptRequestBody(cek, req);

  const client = initHttpClient(JSON.stringify(encryptedReq));

  const init_sign_url = `${process.env.IAM_SMART_DOMAIN}api/v1/anonymous/pdfsigning/initiateRequest`;

  const result = await client.post(init_sign_url, encryptedReq);
  // Decrypt the response's content
  const decryptedRes = await decryptResponse(cek, result.data.content);
  console.log("decryptedRes:", decryptedRes);

  const ticketId = decryptedRes.ticketID;
  return { signCode: signCode, qrcodeUrl: await getQRCodePage(ticketId, lang) };
};

const getAccessTokenOpenID = async (code) => {
  const cek = await getCek();
  const req = {
    code,
    grantType: "authorization_code",
  };
  const encryptedReq = await encryptRequestBody(cek, req);

  const client = initHttpClient(JSON.stringify(encryptedReq));

  const access_token_url = `${process.env.IAM_SMART_DOMAIN}api/v1/auth/getToken`;

  const result = await client.post(access_token_url, encryptedReq);
  console.log("Result", result.data);

  // Decrypt the response's content
  const decryptedRes = await decryptResponse(cek, result.data.content);

  return {
    accessToken: decryptedRes.accessToken,
    openID: decryptedRes.openID,
  };
};

const getSignResult = async (accessToken, openID) => {
  const cek = await getCek();
  const req = {
    accessToken,
    openID,
  };
  const encryptedReq = await encryptRequestBody(cek, req);

  const client = initHttpClient(JSON.stringify(encryptedReq));

  const sign_result_url = `${process.env.IAM_SMART_DOMAIN}api/v1/anonymous/pdfsigning/getResult`;

  const result = await client.post(sign_result_url, encryptedReq);

  // Decrypt the response's content
  const decryptedRes = await decryptResponse(cek, result.data.content);

  // Write the decrypedRes to a temp file
  // fs.writeFileSync(`temp_sign_${new Date().getTime()}.txt`, JSON.stringify({
  //   ...decryptedRes
  //   }))
  return decryptedRes.pdfSignature;
};

const insertSignature = async (businessId, signature) => {
  const file = (
    await sequelize.query(
      `SELECT * FROM IamSmart I INNER JOIN ApplicationFiles A ON I.FileId = A.FileId WHERE I.BusinessId = '${businessId}'`
    )
  )[0][0];
  // Open the file path and store the signature inside
  // let pdfBuffer = await signWithPlaceholder(file.FilePath, null, {
  //   signatureLength: 20998
  // }, null, null)
  let pdfBuffer = fs.readFileSync(file.FilePath);
  const binarySignature = Buffer.from(signature, "base64").toString("binary");
  pdfBuffer = await externalSign(pdfBuffer, binarySignature);
  console.log("Signed pdf length: " + pdfBuffer.length);

  fs.writeFileSync(file.FilePath, pdfBuffer);

  await ApplicationFiles.update(
    {
      SignDate: MOMENT().format("YYYY-MM-DD  HH:mm:ss.0000000"),
      SignType: "iamsmart",
    },
    {
      where: {
        FileId: file.FileId,
      },
    }
  );

  return file.CurrentUrl;
};

module.exports = {
  getKey,
  getCek,
  initHttpClient,
  encryptRequestBody,
  decryptResponse,
  initiateIamsmartRequest,
  getAccessTokenOpenID,
  getSignResult,
  insertSignature,
};

================
File: bd-scs-nodejs-frontend-main/src/utils/loginUtils.js
================
const jwt = require("jsonwebtoken");
const { Op } = require("sequelize");
const SchoolAppInfoModel = require("../models/SchoolAppInfo");
const _jwtConfigAudience = process.env.JWT_AUDIENCE;
const _jwtConfigIssuer = process.env.JWT_ISSUER;
const _jwtConfigSecret = process.env.JWT_SECRET;

require("dotenv").config(); // for reading .env file

async function checkApplicantLogin(user) {
  // Logic to verify user login credentials
  return true; // Add real logic
}

async function getUserJsonWithToken(user) {
  const schoolExisted = await checkUserDataInDB(
    user.applicationNo,
    user.userId
  );

  if (schoolExisted.isExisted) {
    const token = generateToken(user.userId, schoolExisted.role);
    console.log(schoolExisted);
    return {
      userId: user.userId,
      role: schoolExisted.role,
      token: token,
    };
  } else {
    return null;
  }
}

async function generateToken(userId, role) {
  const payload = { userId, role };
  const token = jwt.sign(payload, _jwtConfigSecret, {
    issuer: _jwtConfigIssuer,
    audience: _jwtConfigAudience,
    expiresIn: "3h",
  });
  return token;
}

async function getTokenByUser(user) {
  if (user) {
    const token = generateToken(user.userId, null);
    return {
      userId: user.userId,
      token: token,
    };
  } else {
    return null;
  }
}

async function getTokenByStaff(staff) {
  if (staff) {
    const token = generateToken(staff.userId, staff.role);
    return {
      userId: staff.userId,
      englishName: staff.englishName,
      chineseName: staff.chineseName,
      department: staff.department,
      post: staff.post,
      email: staff.email,
      role: staff.role,
      token: token,
    };
  } else {
    return null;
  }
}

async function checkUserDataInDB(applicationNo, userId) {
  console.log("ApplicationNo", applicationNo);
  console.log("UserId", userId);
  const schoolAppInfo = await SchoolAppInfoModel.findOne({
    where: {
      ApplicationNo: applicationNo,
      [Op.or]: [
        { ApplicantEmail: userId },
        { ApplicantMobile: userId },
        { ContactPEmail: userId },
        { ContactPMobile: userId },
        { EmailOfAp1: userId },
        { MobileOfAp1: userId },
        { EmailOfAp2: userId },
        { MobileOfAp2: userId },
        { EmailOfRse: userId },
        { MobileOfRse: userId },
      ],
    },
    raw: true,
  });

  if (schoolAppInfo) {
    const roles = [];
    console.log(schoolAppInfo);
    if (
      schoolAppInfo.ApplicantEmail === userId ||
      schoolAppInfo.ApplicantMobile === userId
    ) {
      roles.push("APPLICANT");
    }
    if (
      schoolAppInfo.ContactPEmail === userId ||
      schoolAppInfo.ContactPMobile === userId
    ) {
      roles.push("CONTACTP");
    }
    if (
      schoolAppInfo.EmailOfAp1 === userId ||
      schoolAppInfo.MobileOfAp1 === userId
    ) {
      roles.push("AP1");
    }
    if (
      schoolAppInfo.EmailOfAp2 === userId ||
      schoolAppInfo.MobileOfAp2 === userId
    ) {
      roles.push("AP2");
    }
    // Continue for other roles

    return { isExisted: true, role: roles.join(",") };
  }
  return { isExisted: false, role: "" };
}

module.exports = {
  checkApplicantLogin,
  getUserJsonWithToken,
  generateToken,
  getTokenByUser,
  getTokenByStaff,
  checkUserDataInDB,
};

================
File: bd-scs-nodejs-frontend-main/src/utils/on9Dotnet.js
================
const { isArray, transform, isObject, isDate } = require("lodash");

function convertToCamelCase(name) {
  if (!name || !isUpperCase(name[0])) {
    return name;
  }

  const chars = name.split("");
  fixCasing(chars);
  return chars.join("");
}

const camelize = (obj) =>
  transform(obj, (result, value, key, target) => {
    const camelKey = isArray(target) ? key : convertToCamelCase(key);
    result[camelKey] =
      isObject(value) && !isDate(value) ? camelize(value) : value;
  });

function fixCasing(chars) {
  for (let i = 0; i < chars.length; i++) {
    if (i === 1 && !isUpperCase(chars[i])) {
      break;
    }

    const hasNext = i + 1 < chars.length;

    // Stop when the next character is already lowercase.
    if (i > 0 && hasNext && !isUpperCase(chars[i + 1])) {
      // If the next character is a space, lowercase the current character before exiting.
      if (chars[i + 1] === " ") {
        chars[i] = chars[i].toLowerCase();
      }
      break;
    }

    chars[i] = chars[i].toLowerCase();
  }
}

function isUpperCase(char) {
  return char === char.toUpperCase() && char !== char.toLowerCase();
}

module.exports = { camelize };

================
File: bd-scs-nodejs-frontend-main/src/utils/signConfig.js
================
module.exports.signConfig = {
  A2: {
    x: 390,
    y: 200,
  },
  B2: {
    x: 350,
    y: 305,
  },
  C2: {
    x: 370,
    y: 295,
  },
  A3: {
    x: 1000,
    y: 300,
  },
  A4: {
    x: 650,
    y: 210,
  },
  E2: {
    x: 360,
    y: 200,
  },
  F2: {
    x: 360,
    y: 300,
  },
  G2: {
    x: 340,
    y: 285,
  },
  "CCCAI-C2": {
    x: 150,
    y: 100,
  },
  "CCCAI-MH3": {
    x: 150,
    y: 115,
  },
  "EDB-JOKC02": {
    x: 150,
    y: 100,
  },
  "SCS-1": {
    x: 150,
    y: 400,
    page: 3,
  },
};

================
File: bd-scs-nodejs-frontend-main/src/utils/Signer.js
================
/* eslint-disable no-unused-vars */
import * as nodeCrypto from 'crypto';
import * as asn1js from 'asn1js';
import * as pkijs from 'pkijs';
import {ISigner, SignPdfError} from '@signpdf/utils';


// Useful references to understand what is going on here:
//   * PDF: Portable Document Format (ISO 32000-1)
//   * CMS: Cryptographic Message Syntax (RFC 5652)
//   * CAdES: CMS Advanced Electronic Signatures (ETSI 319 122-1)
//   * PAdES: PDF Advanced Electronic Signatures (ETSI 319 142-1)
// Some code comments will refer to these specifications using square brackets,
// e.g. [PDF - 12.8] means section 12.8 of the ISO 32000-1 specification.

// Object identifiers used in the created CMS Signed Data structure
const oids = {
    data: '1.2.840.113549.1.7.1',
    signedData: '1.2.840.113549.1.7.2',
    contentType: '1.2.840.113549.1.9.3',
    messageDigest: '1.2.840.113549.1.9.4',
    signingTime: '1.2.840.113549.1.9.5',
    signingCertificateV2: '1.2.840.113549.1.9.16.2.47',
};

/**
 * Abstract Signer class taking care of creating a suitable signature for a given pdf.
 * Subclasses should specify the required signature and hashing algorithms (either through
 * the `signAlgorithm` and `hashAlgorithm` attributes, or by overriding the `getSignAlgorithm`
 * and `getHashAlgorithm` methods), as well as provide the signing certificate and private key
 * used for signing (by implementing the `getCertificate` and `getKey` methods).
 */
export class Signer extends ISigner {
    /** Signature algorithm used for PDF signing
     * @type {string}
     */
    signAlgorithm = 'RSASSA-PKCS1-v1_5';

    /** Hash algorithm used for PDF signing
     * @type {string}
     */
    hashAlgorithm = 'SHA-256';

    /**
     * Method to retrieve the signature algorithm used for PDF signing.
     * To be implemented by subclasses or set in the `signAlgorithm` attribute.
     * @returns {Promise<string>}
     */
    async getSignAlgorithm() {
        return this.signAlgorithm; // Use default signature algorithm if not overridden by subclass
    }

    /**
     * Method to retrieve the hashing algorithm used for PDF signing.
     * To be implemented by subclasses or set in the `hashAlgorithm` attribute.
     * @returns {Promise<string>}
     */
    async getHashAlgorithm() {
        return this.hashAlgorithm; // Use default hash algorithm if not overridden by subclass
    }

    /**
     * Method to retrieve the signing certificate. If multiple certificates are returned, the first
     * one is used for the actual signing, while the others are added for verification purposes.
     * To be implemented by subclasses.
     * @returns {Promise<Uint8Array | Uint8Array[]>}
     */
    async getCertificate() {
        throw new SignPdfError(
            `getCertificate() is not implemented on ${this.constructor.name}`,
            SignPdfError.TYPE_INPUT,
        );
    }

    /**
     * Method to retrieve the private key used for signing.
     * The returned private key should be in its PKCS#8 binary representation.
     * To be implemented by subclasses.
     * @returns {Promise<Uint8Array>}
     */
    async getKey() {
        throw new SignPdfError(
            `getKey() is not implemented on ${this.constructor.name}`,
            SignPdfError.TYPE_INPUT,
        );
    }

    /**
     * Get a "crypto" extension.
     * @returns {pkijs.ICryptoEngine}
     */
    getCrypto() {
        const crypto = new pkijs.CryptoEngine({name: 'SignerCrypto', crypto: nodeCrypto});
        return crypto;
    }

    /**
     * Obtain the certificates used for signing (first one) and verification (whole list).
     * @returns {pkijs.Certificate[]}
     */
    async obtainCertificates() {
        let certBytes = await this.getCertificate();
        if (!Array.isArray(certBytes)) {
            certBytes = [certBytes];
        }
        return certBytes.map((cb) => pkijs.Certificate.fromBER(cb));
    }

    /**
     * Obtain the private key used for signing.
     * @returns {CryptoKey}
     */
    async obtainKey() {
        const keyBytes = await this.getKey();
        const algorithmParams = this.crypto.getAlgorithmParameters(this.signAlgorithm, 'importkey').algorithm;
        return this.crypto.importKey('pkcs8', keyBytes, {
            name: this.signAlgorithm,
            ...algorithmParams,
            hash: {name: this.hashAlgorithm},
        }, false, ['sign']);
    }

    /**
     * Obtain the signed attributes, which are the actual content that is signed in detached mode.
     * @returns {pkijs.Attribute[]}
     */
    async obtainSignedAttributes(signingTime, data, signCert) {
        // Create a message digest
        const digest = await this.crypto.digest({name: this.hashAlgorithm}, data);
        // Note that the signed attributes order is relevant for correct EU signature validation:
        // https://ec.europa.eu/digital-building-blocks/DSS/webapp-demo/validation
        const signedAttrs = [
            // [CAdES - 5.1.1]
            new pkijs.Attribute({
                type: oids.contentType,
                values: [new asn1js.ObjectIdentifier({value: oids.data})],
            }),
            // [CAdES - 5.2.1]
            new pkijs.Attribute({
                type: oids.signingTime,
                values: [new asn1js.UTCTime({valueDate: signingTime ?? new Date()})],
            }),
            // [CAdES - 5.1.2]
            new pkijs.Attribute({
                type: oids.messageDigest,
                values: [new asn1js.OctetString({valueHex: digest})],
            }),
        ];

        // Add the ESS signing certificate attribute (see [CAdES - 5.2.2.3] and [RFC 5035])
        const hashOid = this.crypto.getOIDByAlgorithm({name: this.hashAlgorithm}, true, 'hashAlgorithm');
        const signCertHash = await this.crypto.digest(
            {name: this.hashAlgorithm},
            signCert.toSchema(true).toBER(false),
        );
        const essCertIDv2 = new asn1js.Sequence({
            value: [
                // hashAlgorithm
                new asn1js.Sequence({value: [new asn1js.ObjectIdentifier({value: hashOid})]}),
                // certHash
                new asn1js.OctetString({valueHex: signCertHash}),
                // issuerSerial (omitted here; contained in signerInfo)
            ],
        });
        const signingCertificateV2 = new asn1js.Sequence({
            value: [
                // certs
                new asn1js.Sequence({value: [essCertIDv2]}),
                // policies (shall not be used according to [CAdES - 5.2.2.3])
            ],
        });
        signedAttrs.push(new pkijs.Attribute({
            type: oids.signingCertificateV2,
            values: [signingCertificateV2],
        }));
        return signedAttrs;
    }

    /**
     * Obtain the unsigned attributes.
     * @returns {pkijs.Attribute[]}
     */
    async obtainUnsignedAttributes(signature) {
        return [];
    }

    /**
     * @param {Buffer} pdfBuffer
     * @param {Date | undefined} signingTime
     * @returns {Promise<Buffer>}
     */
    async sign(pdfBuffer, signingTime = undefined) {
        if (!(pdfBuffer instanceof Buffer)) {
            throw new SignPdfError(
                'PDF expected as Buffer.',
                SignPdfError.TYPE_INPUT,
            );
        }

        // Get signature and hash algorithms
        this.signAlgorithm = await this.getSignAlgorithm();
        this.hashAlgorithm = await this.getHashAlgorithm();
        // Get a crypto extension
        this.crypto = this.getCrypto();
        // Get the signing (and verification) certificates
        const certificates = await this.obtainCertificates();
        const signCert = certificates[0];
        // Obtain the private key used for signing
        const key = await this.obtainKey();

        // Creation of the CMS Signed Data structure (see [PDF - 12.8.3.3] and [PAdES - 4.1])
        // Setup signer info (see [CMS - 5.3])
        const signerInfo = new pkijs.SignerInfo({
            version: 1,
            sid: new pkijs.IssuerAndSerialNumber({
                issuer: signCert.issuer,
                serialNumber: signCert.serialNumber,
            }),
            signedAttrs: new pkijs.SignedAndUnsignedAttributes({
                type: 0,
                attributes: await this.obtainSignedAttributes(signingTime, pdfBuffer, signCert),
            }),
        });

        // Initialize CMS Signed Data structure (see [CMS - 5.1]) and sign it
        const cmsSignedData = new pkijs.SignedData({
            version: 1,
            encapContentInfo: new pkijs.EncapsulatedContentInfo({
                eContentType: oids.data, // No actual econtent here, as we sign in detached mode
            }),
            signerInfos: [signerInfo],
            certificates,
        });

        // Sign in detached mode. That's what Adobe.PPKLite expects for subfilters
        // adbe.pkcs7.detached and ETSI.CAdES.detached.
        await cmsSignedData.sign(key, 0, this.hashAlgorithm, undefined, this.crypto);

        // Append the unsigned attributes, if there are any
        const unsignedAttrs = await this.obtainUnsignedAttributes(signerInfo.signature.getValue());
        if (unsignedAttrs.length > 0) {
            signerInfo.unsignedAttrs = new pkijs.SignedAndUnsignedAttributes({
                type: 1,
                attributes: unsignedAttrs,
            });
        }

        // Create final result
        const cmsContentWrap = new pkijs.ContentInfo({
            contentType: oids.signedData,
            content: cmsSignedData.toSchema(true),
        });

        return Buffer.from(cmsContentWrap.toSchema().toBER(false));
    }

    /**
     * Verify whether the signature generated by the sign function is correct.
     * @param {Buffer} cmsSignedBuffer
     * @param {Buffer} pdfBuffer
     * @returns {boolean}
     */
    async verify(cmsSignedBuffer, pdfBuffer) {
        // Based on cmsSignedComplexExample from PKI.js
        const cmsContentSimpl = pkijs.ContentInfo.fromBER(cmsSignedBuffer);
        const cmsSignedSimpl = new pkijs.SignedData({schema: cmsContentSimpl.content});

        return cmsSignedSimpl.verify({
            signer: 0,
            trustedCerts: [],
            data: pdfBuffer,
        }, this.getCrypto());
    }
}

================
File: bd-scs-nodejs-frontend-main/src/utils/signUtils.js
================
const fs = require("fs");
var {
  PDFDocument,
  StandardFonts,
  rgb,
  CustomFontSubsetEmbedder,
} = require("pdf-lib");
var pdflibAddPlaceholder =
  require("@signpdf/placeholder-pdf-lib").pdflibAddPlaceholder;
var signpdf = require("@signpdf/signpdf").default;
var _utils = require("@signpdf/utils");
const crypto = require("crypto");
const fontkit = require("@pdf-lib/fontkit");

const hexDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

function base64Decode(input) {
  return Buffer.from(input, "base64");
}

function digestToByte(data, algorithm) {
  const hash = crypto.createHash(algorithm);
  hash.update(data);
  return hash.digest();
}

function getSignCode(documentHash, hkiCHash, clientID) {
  // console.log(documentHash, hkiCHash, clientID);
  const documentHashBytes = base64Decode(documentHash);

  // Step 2: Decode the SHA-256 hashed HKIC
  const hkiCHashBytes = base64Decode(hkiCHash);

  // Step 3: Calculate SHA-512 hash of the clientID
  const clientIDBytes = digestToByte(clientID, "sha512");
  // Step 4: Concatenate Document Hash, HKIC Hash, and SHA-512 hashed clientID
  const source = Buffer.concat([
    documentHashBytes,
    hkiCHashBytes,
    clientIDBytes,
  ]);

  // Step 5: Calculate SHA-512 hash of the concatenated data
  const inData = digestToByte(source, "sha512");

  // Step 6: Calculate MD5 hash of the SHA-512 result
  const digestMD5Data = digestToByte(inData, "md5");

  // Step 7: Convert the first 4 bytes of the MD5 hash into a 4-digit identification code
  const code = [];
  for (let i = 0; i < 4; i++) {
    // Extract hexadecimal digits and map to `hexDigits`
    code[i] = hexDigits[((digestMD5Data[i * 4] >>> 4) & 0xf) % 10];
  }

  // Return the generated 4-digit code
  return code.join("");
}

function getHash(bytes) {
  return crypto.createHash("sha256").update(bytes).digest("base64");
}

const signWithPlaceholder = async (
  filePath,
  targetPath,
  placeholder = null,
  signer = null,
  visibleSignature = null
) => {
  console.log(filePath);
  var pdfBuffer = fs.readFileSync(filePath);
  let pdfDoc = await PDFDocument.load(pdfBuffer);

  pdfDoc.registerFontkit(fontkit);

  const fontBytes = await new Promise((resolve) =>
    fs.readFile("./public/fonts/Microsoft JhengHei Bold.ttf", (err, data) => {
      if (err) {
        console.log("Font not loaded", err);
        resolve(null);
      } else resolve(data.buffer);
    })
  );
  let customFont;
  if (fontBytes) {
    pdfDoc.registerFontkit(fontkit);
    await pdfDoc.embedFont(fontBytes);
    customFont = await pdfDoc.embedFont(fontBytes);
  }
  if (visibleSignature) {
    const { x, y, pageNo, fontSize, displayText } = visibleSignature;
    const pages = pdfDoc.getPages();
    const firstPage = pages[pageNo];
    // const { width, height } = firstPage.getSize();
    firstPage.drawText(displayText, {
      x: x,
      y: y,
      size: fontSize,
      font: customFont || (await pdfDoc.embedFont(StandardFonts.Helvetica)),
      color: rgb(0, 0, 0),
    });
  }

  if (placeholder) {
    // Add a placeholder for a signature.
    pdflibAddPlaceholder({
      pdfDoc: pdfDoc,
      reason: "The user is declaring consent through JavaScript.",
      contactInfo: "signpdf@example.com",
      name: "John Doe",
      location: "Free Text Str., Free World",
      team: "Signority",
      byteRangePlaceholder: "**********",
      ...placeholder,
    });
  }

  if (placeholder || visibleSignature) {
    pdfBuffer = await pdfDoc.save();
  }

  if (signer) {
    pdfBuffer = await signpdf.sign(pdfBuffer, signer);
  }

  if (targetPath) {
    fs.writeFileSync(targetPath, pdfBuffer);
  }
  return pdfBuffer;
};

const externalSign = async (pdfBuffer, raw, signingTime = undefined) => {
  //   if (!(signer instanceof _utils.Signer)) {
  //     throw new _utils.SignPdfError(
  //       "Signer implementation expected.",
  //       _utils.SignPdfError.TYPE_INPUT
  //     );
  //   }
  let pdf = (0, _utils.removeTrailingNewLine)(
    (0, _utils.convertBuffer)(pdfBuffer, "PDF")
  );

  // Find the ByteRange placeholder.
  const { byteRangePlaceholder, byteRangePlaceholderPosition } = (0,
  _utils.findByteRange)(pdf);
  if (!byteRangePlaceholder) {
    throw new _utils.SignPdfError(
      "No ByteRangeStrings found within PDF buffer.",
      _utils.SignPdfError.TYPE_PARSE
    );
  }

  // Calculate the actual ByteRange that needs to replace the placeholder.
  const byteRangeEnd =
    byteRangePlaceholderPosition + byteRangePlaceholder.length;
  const contentsTagPos = pdf.indexOf("/Contents ", byteRangeEnd);
  const placeholderPos = pdf.indexOf("<", contentsTagPos);
  const placeholderEnd = pdf.indexOf(">", placeholderPos);
  const placeholderLengthWithBrackets = placeholderEnd + 1 - placeholderPos;
  const placeholderLength = placeholderLengthWithBrackets - 2;
  const byteRange = [0, 0, 0, 0];
  byteRange[1] = placeholderPos;
  byteRange[2] = byteRange[1] + placeholderLengthWithBrackets;
  byteRange[3] = pdf.length - byteRange[2];
  let actualByteRange = `/ByteRange [${byteRange.join(" ")}]`;
  actualByteRange += " ".repeat(
    byteRangePlaceholder.length - actualByteRange.length
  );

  // Replace the /ByteRange placeholder with the actual ByteRange
  pdf = Buffer.concat([
    pdf.slice(0, byteRangePlaceholderPosition),
    Buffer.from(actualByteRange),
    pdf.slice(byteRangeEnd),
  ]);

  // Remove the placeholder signature
  pdf = Buffer.concat([
    pdf.slice(0, byteRange[1]),
    pdf.slice(byteRange[2], byteRange[2] + byteRange[3]),
  ]);
  //   const raw = await signer.sign(pdf, signingTime);

  // Check if the PDF has a good enough placeholder to fit the signature.
  // placeholderLength represents the length of the HEXified symbols but we're
  // checking the actual lengths.
  if (raw.length * 2 > placeholderLength) {
    throw new _utils.SignPdfError(
      `Signature exceeds placeholder length: ${
        raw.length * 2
      } > ${placeholderLength}`,
      _utils.SignPdfError.TYPE_INPUT
    );
  }
  let signature = Buffer.from(raw, "binary").toString("hex");
  // Store the HEXified signature. At least useful in tests.
  this.lastSignature = signature;

  // Pad the signature with zeroes so the it is the same length as the placeholder
  signature += Buffer.from(
    String.fromCharCode(0).repeat(placeholderLength / 2 - raw.length)
  ).toString("hex");

  // Place it in the document.
  pdf = Buffer.concat([
    pdf.slice(0, byteRange[1]),
    Buffer.from(`<${signature}>`),
    pdf.slice(byteRange[1]),
  ]);

  // Magic. Done.
  return pdf;
};

const prepareDocDigest = async (pdfBuffer) => {
  //   if (!(signer instanceof _utils.Signer)) {
  //     throw new _utils.SignPdfError(
  //       "Signer implementation expected.",
  //       _utils.SignPdfError.TYPE_INPUT
  //     );
  //   }
  let pdf = (0, _utils.removeTrailingNewLine)(
    (0, _utils.convertBuffer)(pdfBuffer, "PDF")
  );

  // Find the ByteRange placeholder.
  const { byteRangePlaceholder, byteRangePlaceholderPosition } = (0,
  _utils.findByteRange)(pdf);
  if (!byteRangePlaceholder) {
    throw new _utils.SignPdfError(
      "No ByteRangeStrings found within PDF buffer.",
      _utils.SignPdfError.TYPE_PARSE
    );
  }

  // Calculate the actual ByteRange that needs to replace the placeholder.
  const byteRangeEnd =
    byteRangePlaceholderPosition + byteRangePlaceholder.length;
  const contentsTagPos = pdf.indexOf("/Contents ", byteRangeEnd);
  const placeholderPos = pdf.indexOf("<", contentsTagPos);
  const placeholderEnd = pdf.indexOf(">", placeholderPos);
  const placeholderLengthWithBrackets = placeholderEnd + 1 - placeholderPos;
  const placeholderLength = placeholderLengthWithBrackets - 2;
  const byteRange = [0, 0, 0, 0];
  byteRange[1] = placeholderPos;
  byteRange[2] = byteRange[1] + placeholderLengthWithBrackets;
  byteRange[3] = pdf.length - byteRange[2];
  let actualByteRange = `/ByteRange [${byteRange.join(" ")}]`;
  actualByteRange += " ".repeat(
    byteRangePlaceholder.length - actualByteRange.length
  );

  // Replace the /ByteRange placeholder with the actual ByteRange
  pdf = Buffer.concat([
    pdf.slice(0, byteRangePlaceholderPosition),
    Buffer.from(actualByteRange),
    pdf.slice(byteRangeEnd),
  ]);

  // Remove the placeholder signature
  pdf = Buffer.concat([
    pdf.slice(0, byteRange[1]),
    pdf.slice(byteRange[2], byteRange[2] + byteRange[3]),
  ]);

  return getHash(pdf);
};

module.exports = {
  signWithPlaceholder,
  externalSign,
  prepareDocDigest,
  getSignCode,
};

================
File: bd-scs-react-frontend-frontend-main/.eslintrc.js
================
// @see: http://eslint.cn

module.exports = {
	settings: {
		react: {
			version: "detect"
		}
	},
	root: true,
	env: {
		browser: true,
		node: true,
		es6: true
	},
	/* 指定如何解析语法 */
	parser: "@typescript-eslint/parser",
	/* 优先级低于 parse 的语法解析配置 */
	parserOptions: {
		ecmaVersion: 2020,
		sourceType: "module",
		jsxPragma: "React",
		ecmaFeatures: {
			jsx: true
		}
	},
	plugins: ["react", "@typescript-eslint", "react-hooks", "prettier"],
	/* 继承某些已有的规则 */
	extends: [
		"eslint:recommended",
		"plugin:react/recommended",
		"plugin:@typescript-eslint/recommended",
		"plugin:react/jsx-runtime",
		"plugin:react-hooks/recommended",
		"prettier",
		"plugin:prettier/recommended"
	],
	/*
	 * "off" 或 0    ==>  关闭规则
	 * "warn" 或 1   ==>  打开的规则作为警告（不影响代码执行）
	 * "error" 或 2  ==>  规则作为一个错误（代码不能执行，界面报错）
	 */
	rules: {
		// eslint (http://eslint.cn/docs/rules)
		"no-var": "error", // 要求使用 let 或 const 而不是 var
		"no-multiple-empty-lines": ["error", { max: 1 }], // 不允许多个空行
		"no-use-before-define": "off", // 禁止在 函数/类/变量 定义之前使用它们
		"prefer-const": "off", // 此规则旨在标记使用 let 关键字声明但在初始分配后从未重新分配的变量，要求使用 const
		"no-irregular-whitespace": "off", // 禁止不规则的空白
		"prettier/prettier": "off",

		// typeScript (https://typescript-eslint.io/rules)
		"@typescript-eslint/no-unused-vars": "off", // 禁止定义未使用的变量
		"@typescript-eslint/no-inferrable-types": "off", // 可以轻松推断的显式类型可能会增加不必要的冗长
		"@typescript-eslint/no-namespace": "off", // 禁止使用自定义 TypeScript 模块和命名空间。
		"@typescript-eslint/no-explicit-any": "off", // 禁止使用 any 类型
		"@typescript-eslint/ban-ts-ignore": "off", // 禁止使用 @ts-ignore
		"@typescript-eslint/ban-types": "off", // 禁止使用特定类型
		"@typescript-eslint/explicit-function-return-type": "off", // 不允许对初始化为数字、字符串或布尔值的变量或参数进行显式类型声明
		"@typescript-eslint/no-var-requires": "off", // 不允许在 import 语句中使用 require 语句
		"@typescript-eslint/no-empty-function": "off", // 禁止空函数
		"@typescript-eslint/no-use-before-define": "off", // 禁止在变量定义之前使用它们
		"@typescript-eslint/ban-ts-comment": "off", // 禁止 @ts-<directive> 使用注释或要求在指令后进行描述
		"@typescript-eslint/no-non-null-assertion": "off", // 不允许使用后缀运算符的非空断言(!)
		"@typescript-eslint/explicit-module-boundary-types": "off", // 要求导出函数和类的公共类方法的显式返回和参数类型

		// react (https://github.com/jsx-eslint/eslint-plugin-react)
		"react-hooks/rules-of-hooks": "error",
		"react-hooks/exhaustive-deps": "off"
	}
};

================
File: bd-scs-react-frontend-frontend-main/.prettierrc.js
================
// @see: https://www.prettier.cn

module.exports = {
	// 超过最大值换行
	printWidth: 200,
	// 缩进字节数
	tabWidth: 4,
	// 使用制表符而不是空格缩进行
	useTabs: false,
	// 结尾不用分号(true有，false没有)
	semi: true,
	// 使用单引号(true单双引号，false双引号)
	singleQuote: false,
	// 更改引用对象属性的时间 可选值"<as-needed|consistent|preserve>"
	quoteProps: "as-needed",
	// 在对象，数组括号与文字之间加空格 "{ foo: bar }"
	bracketSpacing: true,
	// 多行时尽可能打印尾随逗号。（例如，单行数组永远不会出现逗号结尾。） 可选值"<none|es5|all>"，默认none
	trailingComma: "none",
	// 在JSX中使用单引号而不是双引号
	jsxSingleQuote: false,
	//  (x) => {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 ,always：不省略括号
	arrowParens: "avoid",
	// 如果文件顶部已经有一个 doclock，这个选项将新建一行注释，并打上@format标记。
	insertPragma: false,
	// 指定要使用的解析器，不需要写文件开头的 @prettier
	requirePragma: false,
	// 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行
	proseWrap: "preserve",
	// 在html中空格是否是敏感的 "css" - 遵守CSS显示属性的默认值， "strict" - 空格被认为是敏感的 ，"ignore" - 空格被认为是不敏感的
	htmlWhitespaceSensitivity: "css",
	// 换行符使用 lf 结尾是 可选值"<auto|lf|crlf|cr>"
	endOfLine: "auto",
	// 这两个选项可用于格式化以给定字符偏移量（分别包括和不包括）开始和结束的代码
	rangeStart: 0,
	rangeEnd: Infinity,
	// Vue文件脚本和样式标签缩进
	vueIndentScriptAndStyle: false
};

================
File: bd-scs-react-frontend-frontend-main/.stylelintrc.js
================
// @see: https://stylelint.io

module.exports = {
	extends: [
		"stylelint-config-standard", // 配置stylelint拓展插件
		"stylelint-config-prettier", // 配置stylelint和prettier兼容
		"stylelint-config-recess-order" // 配置stylelint css属性书写顺序插件,
	],
	plugins: ["stylelint-less"], // 配置stylelint less拓展插件
	rules: {
		indentation: null, // 指定缩进空格
		"no-descending-specificity": null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器
		"function-url-quotes": "always", // 要求或禁止 URL 的引号 "always(必须加上引号)"|"never(没有引号)"
		"string-quotes": "double", // 指定字符串使用单引号或双引号
		"unit-case": null, // 指定单位的大小写 "lower(全小写)"|"upper(全大写)"
		"color-hex-case": "lower", // 指定 16 进制颜色的大小写 "lower(全小写)"|"upper(全大写)"
		"color-hex-length": "long", // 指定 16 进制颜色的简写或扩写 "short(16进制简写)"|"long(16进制扩写)"
		"rule-empty-line-before": "never", // 要求或禁止在规则之前的空行 "always(规则之前必须始终有一个空行)"|"never(规则前绝不能有空行)"|"always-multi-line(多行规则之前必须始终有一个空行)"|"never-multi-line(多行规则之前绝不能有空行。)"
		"font-family-no-missing-generic-family-keyword": null, // 禁止在字体族名称列表中缺少通用字体族关键字
		"block-opening-brace-space-before": "always", // 要求在块的开大括号之前必须有一个空格或不能有空白符 "always(大括号前必须始终有一个空格)"|"never(左大括号之前绝不能有空格)"|"always-single-line(在单行块中的左大括号之前必须始终有一个空格)"|"never-single-line(在单行块中的左大括号之前绝不能有空格)"|"always-multi-line(在多行块中，左大括号之前必须始终有一个空格)"|"never-multi-line(多行块中的左大括号之前绝不能有空格)"
		"property-no-unknown": null, // 禁止未知的属性(true 为不允许)
		"no-empty-source": null, // 禁止空源码
		"declaration-block-trailing-semicolon": null, // 要求或不允许在声明块中使用尾随分号 string："always(必须始终有一个尾随分号)"|"never(不得有尾随分号)"
		"selector-class-pattern": null, // 强制选择器类名的格式
		"value-no-vendor-prefix": null, // 关闭 vendor-prefix(为了解决多行省略 -webkit-box)
		"at-rule-no-unknown": null,
		"selector-pseudo-class-no-unknown": [
			true,
			{
				ignorePseudoClasses: ["global", "v-deep", "deep"]
			}
		]
	}
};

================
File: bd-scs-react-frontend-frontend-main/commitlint.config.js
================
// @see: https://cz-git.qbenben.com/zh/guide
/** @type {import('cz-git').UserConfig} */

module.exports = {
	ignores: [commit => commit.includes("init")],
	extends: ["@commitlint/config-conventional"],
	rules: {
		// @see: https://commitlint.js.org/#/reference-rules
		"body-leading-blank": [2, "always"],
		"footer-leading-blank": [1, "always"],
		"header-max-length": [2, "always", 108],
		"subject-empty": [2, "never"],
		"type-empty": [2, "never"],
		"subject-case": [0],
		"type-enum": [
			2,
			"always",
			[
				"feat",
				"fix",
				"docs",
				"style",
				"refactor",
				"perf",
				"test",
				"build",
				"ci",
				"chore",
				"revert",
				"wip",
				"workflow",
				"types",
				"release"
			]
		]
	},
	prompt: {
		messages: {
			type: "Select the type of change that you're committing:",
			scope: "Denote the SCOPE of this change (optional):",
			customScope: "Denote the SCOPE of this change:",
			subject: "Write a SHORT, IMPERATIVE tense description of the change:\n",
			body: 'Provide a LONGER description of the change (optional). Use "|" to break new line:\n',
			breaking: 'List any BREAKING CHANGES (optional). Use "|" to break new line:\n',
			footerPrefixsSelect: "Select the ISSUES type of changeList by this change (optional):",
			customFooterPrefixs: "Input ISSUES prefix:",
			footer: "List any ISSUES by this change. E.g.: #31, #34:\n",
			confirmCommit: "Are you sure you want to proceed with the commit above?"
			// 中文版
			// type: "选择你要提交的类型 :",
			// scope: "选择一个提交范围（可选）:",
			// customScope: "请输入自定义的提交范围 :",
			// subject: "填写简短精炼的变更描述 :\n",
			// body: '填写更加详细的变更描述（可选）。使用 "|" 换行 :\n',
			// breaking: '列举非兼容性重大的变更（可选）。使用 "|" 换行 :\n',
			// footerPrefixsSelect: "选择关联issue前缀（可选）:",
			// customFooterPrefixs: "输入自定义issue前缀 :",
			// footer: "列举关联issue (可选) 例如: #31, #I3244 :\n",
			// confirmCommit: "是否提交或修改commit ?"
		},
		types: [
			{
				value: "feat",
				name: "feat:     🚀  A new feature",
				emoji: "🚀"
			},
			{
				value: "fix",
				name: "fix:      🧩  A bug fix",
				emoji: "🧩"
			},
			{
				value: "docs",
				name: "docs:     📚  Documentation only changes",
				emoji: "📚"
			},
			{
				value: "style",
				name: "style:    🎨  Changes that do not affect the meaning of the code",
				emoji: "🎨"
			},
			{
				value: "refactor",
				name: "refactor: ♻️   A code change that neither fixes a bug nor adds a feature",
				emoji: "♻️"
			},
			{
				value: "perf",
				name: "perf:     ⚡️  A code change that improves performance",
				emoji: "⚡️"
			},
			{
				value: "test",
				name: "test:     ✅  Adding missing tests or correcting existing tests",
				emoji: "✅"
			},
			{
				value: "build",
				name: "build:    📦️   Changes that affect the build system or external dependencies",
				emoji: "📦️"
			},
			{
				value: "ci",
				name: "ci:       🎡  Changes to our CI configuration files and scripts",
				emoji: "🎡"
			},
			{
				value: "chore",
				name: "chore:    🔨  Other changes that don't modify src or test files",
				emoji: "🔨"
			},
			{
				value: "revert",
				name: "revert:   ⏪️  Reverts a previous commit",
				emoji: "⏪️"
			}
			// 中文版
			// { value: "特性", name: "特性:   🚀  新增功能", emoji: "🚀" },
			// { value: "修复", name: "修复:   🧩  修复缺陷", emoji: "🧩" },
			// { value: "文档", name: "文档:   📚  文档变更", emoji: "📚" },
			// { value: "格式", name: "格式:   🎨  代码格式（不影响功能，例如空格、分号等格式修正）", emoji: "🎨" },
			// { value: "重构", name: "重构:   ♻️  代码重构（不包括 bug 修复、功能新增）", emoji: "♻️" },
			// { value: "性能", name: "性能:   ⚡️  性能优化", emoji: "⚡️" },
			// { value: "测试", name: "测试:   ✅  添加疏漏测试或已有测试改动", emoji: "✅" },
			// { value: "构建", name: "构建:   📦️  构建流程、外部依赖变更（如升级 npm 包、修改 webpack 配置等）", emoji: "📦️" },
			// { value: "集成", name: "集成:   🎡  修改 CI 配置、脚本", emoji: "🎡" },
			// { value: "回退", name: "回退:   ⏪️  回滚 commit", emoji: "⏪️" },
			// { value: "其他", name: "其他:   🔨  对构建过程或辅助工具和库的更改（不影响源文件、测试用例）", emoji: "🔨" }
		],
		useEmoji: true,
		themeColorCode: "",
		scopes: [],
		allowCustomScopes: true,
		allowEmptyScopes: true,
		customScopesAlign: "bottom",
		customScopesAlias: "custom",
		emptyScopesAlias: "empty",
		upperCaseSubject: false,
		allowBreakingChanges: ["feat", "fix"],
		breaklineNumber: 100,
		breaklineChar: "|",
		skipQuestions: [],
		issuePrefixs: [{ value: "closed", name: "closed:   ISSUES has been processed" }],
		customIssuePrefixsAlign: "top",
		emptyIssuePrefixsAlias: "skip",
		customIssuePrefixsAlias: "custom",
		allowCustomIssuePrefixs: true,
		allowEmptyIssuePrefixs: true,
		confirmColorize: true,
		maxHeaderLength: Infinity,
		maxSubjectLength: Infinity,
		minSubjectLength: 0,
		scopeOverrides: undefined,
		defaultBody: "",
		defaultIssues: "",
		defaultScope: "",
		defaultSubject: ""
	}
};

================
File: bd-scs-react-frontend-frontend-main/lint-staged.config.js
================
module.exports = {
	"*.{js,jsx,ts,tsx}": ["eslint --fix", "prettier --write"],
	"{!(package)*.json,*.code-snippets,.!(browserslist)*rc}": ["prettier --write--parser json"],
	"package.json": ["prettier --write"],
	"*.{scss,less,styl}": ["stylelint --fix", "prettier --write"],
	"*.md": ["prettier --write"]
};

================
File: bd-scs-react-frontend-frontend-main/postcss.config.js
================
module.exports = {
    plugins: {
        tailwindcss: {},
        autoprefixer: {}
    }
};

================
File: bd-scs-react-frontend-frontend-main/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
    theme: {
        extend: {}
    },
    plugins: [],
    corePlugins: {
        preflight: false // <== disable this!
    }
};
